{"componentChunkName":"component---src-templates-blog-post-js","path":"/An HTTP Debug Experience/","result":{"data":{"site":{"siteMetadata":{"title":"Mingxin","siteUrl":"https://mingxin.io"}},"markdownRemark":{"id":"66693d0e-d2e0-5363-9082-83cfdcbe8db0","excerpt":"最近有同事反馈，调用服务A的内部接口会偶现超时错误。于是开始查出错的原因。 首先了解了具体情况，调用方的设置的超时时间是2s；错误是偶发的；超时之后重试一般都会成功。 再往服务里加了一些debug日志，最后查出来是这个服务A调用另一个服务B的时候会超时。这个调用设置的超时时间是5s，所以这个请求超时之前，那边2s…","html":"<p>最近有同事反馈，调用服务A的内部接口会偶现超时错误。于是开始查出错的原因。</p>\n<p>首先了解了具体情况，调用方的设置的超时时间是2s；错误是偶发的；超时之后重试一般都会成功。</p>\n<p>再往服务里加了一些debug日志，最后查出来是这个服务A调用另一个服务B的时候会超时。这个调用设置的超时时间是5s，所以这个请求超时之前，那边2s的请求就已经先报超时错误了。这是错误的表象，深层的原因还需要去服务B里查看。</p>\n<p>在服务B里查看对应的日志，发现这些超时的请求都会报出一个<code class=\"language-text\">Error: Parse Error</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Error: Parse Error\nat socketOnEnd (_http_server.js:455:20)\nat Socket.emit (events.js:203:15)\nat Socket.EventEmitter.emit (domain.js:448:20)\nat endReadableNT (_stream_readable.js:1129:12)\nat process._tickCallback (internal/process/next_tick.js:63:19)</code></pre></div>\n<p>查看对应的代码<a href=\"https://github.com/nodejs/node/blob/v10.16.0/lib/_http_server.js#L455-L461\"><em>http</em>server.js</a>，这个错误是由client超时关闭socket，server在处理socket end事件时释放HTTP parser出错导致的。</p>\n<p>这说明HTTP请求的解析失败，可能是server收到了一个错误格式的HTTP请求。不过这里我有了另一个疑问，server在一个无法解析的HTTP请求上为什么没有马上报错，而是hang up直到5s之后超时？</p>\n<p>所以怀疑是A服务的HTTP请求库 <a href=\"https://github.com/request/request\">request</a>会偶尔发送一个错误格式的HTTP请求过去。在github找到一个可能相关的request的<a href=\"https://github.com/request/request/issues/2047\">issue</a>，尤其是里面有一个<a href=\"https://github.com/request/request/issues/2047#issuecomment-471077041\">comment</a>和我遇到的现象很相似。不过这些都是猜测，要证明是request的问题，还是需要找到一个错误格式的HTTP请求的例子。</p>\n<p>因为server在接受到HTTP请求的时候无法解析hang up了，不能在HTTP协议这一层去获取到数据。所以尝试在TCP层去输出数据。多亏Node.js是事件驱动的特性，输出socket的数据只需要在socket上增加一个data事件的listener: </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> Koa <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'koa'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Koa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> server <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span>app<span class=\"token punctuation\">.</span><span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'port'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'connection'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">socket</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  socket<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">d</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'%d socket data: %s'</span><span class=\"token punctuation\">,</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// stringify是为了输出日志到一行</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>注：测试时发现这种做法会与koa-morgan middleware冲突，会让之后的handler无法读取到body。所以如果使用了morgan需要暂时禁用。</p>\n<p>加了日志之后觉得终于可以抓到错误格式的请求了，没想到这个bug就玩消失了-_-（可能是具有量子力学不可观测性的bug）。一周之后终于找到几个日志，错误的http请求是长这样的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">POST /list HTTP/1.1\\r\\ncontent-type: application/json\\r\\naccept-encoding: gzipundefined deflate\\r\\naccept: application/json\\r\\ncontent-length: 117\\r\\nConnection: close\\r\\n\\r\\n</code></pre></div>\n<p>这个请求应该传递117字节的数据，但是却没有传对应的body，所以解析失败。</p>\n<p>这也解释了为什么server为什么会hang up到超时，因为header里指定了content-length，但是却没有传对应的body，server认为还有数据没有传过来，于是一直在等待后续的数据。在client超时关闭连接后，server的HTTP parser就报错了。</p>\n<p>由于request<a href=\"https://github.com/request/request#deprecated\">已经不在维护</a>，最后换用了<a href=\"https://github.com/sindresorhus/got\">got</a>来解决这个问题。</p>","frontmatter":{"title":"一次http debug经历","date":"May 22, 2020","description":"_"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/An HTTP Debug Experience/","previous":{"fields":{"slug":"/VXLAN&Flannel/"},"frontmatter":{"title":"VXLAN & Flannel"}},"next":null}}}