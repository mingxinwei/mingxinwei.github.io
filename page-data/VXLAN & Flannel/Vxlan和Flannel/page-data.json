{"componentChunkName":"component---src-templates-blog-post-js","path":"/VXLAN & Flannel/Vxlan和Flannel/","result":{"data":{"site":{"siteMetadata":{"title":"Mingxin"}},"markdownRemark":{"id":"2a2f1822-ab97-5a98-9b37-f36202631bc4","excerpt":"VXLAN是什么 Virtual Extensible LAN(VXLAN)是一个在三层网络上模拟二层网络的网络虚拟化技术。可以解决云计算场景下子网不够用的问题。 有一个和VXLAN名字和解决的问题都很相似的技术：VLAN，VXLAN和VLAN相比的优点是什么？ 传统VLAN只能支持 4000 个子网，VXLAN…","html":"<h3>VXLAN是什么</h3>\n<p>Virtual Extensible LAN(VXLAN)是一个在三层网络上模拟二层网络的网络虚拟化技术。可以解决云计算场景下子网不够用的问题。</p>\n<p>有一个和VXLAN名字和解决的问题都很相似的技术：VLAN，VXLAN和VLAN相比的优点是什么？</p>\n<p>传统VLAN只能支持 4000 个子网，VXLAN可以支持 1600 万个子网。</p>\n<h3>VXLAN原理</h3>\n<p>使用三层网络的udp包来封装二层的数据包。</p>\n<h4>包结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8eebca9b5c20497d223e8f0e3c856c81/3cdf1/vnet-vxlan-20191107165758344.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.410008779631255%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAACf0lEQVQoz02RXUjTARTF11sPFRG99hYUPRRGWA8VPvYiRJbWjIr8SkijILEQ8yOtLPPBItDCraVrzpXOrTl1S3OburkP59x0m7ql07CVaTl1hb/+Sg9dOJzDvdzDuVzR4KANq20Iu8PFx85OBu7fYKQyH3PFLZofldL8uJyWqlKUG/phidArQfGPN+aKiiK0tVWY+gdxu0cQOZwu7HYn9mEPZr2OSMo+SN+PLeUgOxu8bFMvsqPWzJmsfMSZuZTXPGc0FGHAM86If5I2h58XxXewC6E8oz5E/YLzJqx2utta8aYe4seVI1jSEkmqlHG0pp2ke3VkZ+aQl51DZUkpGpUKlVyORqnkleQNL+/exCJ4uFxuRKFQGK/Xx7g/QMDvZ8SgY6hdibtLw1jHe6zK1/gEtuk1dDbL0b9tRNsoRa9opEMuo6tJiuWDWtgPMjMzgwih4mtrRCIRlpaWiK/D4kqcxd/rRGNxwtEFvq/9YWk1zmpsmYXoPCu/fvJ/La+uEovFNrUoGAwSCATw+Xy4h4fxeEYJOIcImw1MmLoZM+oI9uqZ9Q4zODmLxhVAPeSj1T6GNziJxWTCJMBgMAr7wslWq43ubiNdAnqMPRgtVryyZ8ykJxBOP8z05WOETu8lWl/GKeNXtkgm2N40xa6WOeq7+snNuEpmTi5i8UWeVD9FZDJZ0Gh1qNUatO1a1J1GPNJa5i4l8lkwm844SfjsAb41PCC5J8pW2RS75SH2vPuCxGjlenY2GVnXSE27QPWGocPhpKf3E319QnQBZpuD8XYFwdvn8Becx18oxpeXzLyqjnzLHAmKUU6oxjjeNoHK7KCsqIhi4fMFBYVIJFL+AppxJ65sXr/CAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img\"\n        title=\"img\"\n        src=\"/static/8eebca9b5c20497d223e8f0e3c856c81/799d3/vnet-vxlan-20191107165758344.png\"\n        srcset=\"/static/8eebca9b5c20497d223e8f0e3c856c81/00d96/vnet-vxlan-20191107165758344.png 148w,\n/static/8eebca9b5c20497d223e8f0e3c856c81/0b23c/vnet-vxlan-20191107165758344.png 295w,\n/static/8eebca9b5c20497d223e8f0e3c856c81/799d3/vnet-vxlan-20191107165758344.png 590w,\n/static/8eebca9b5c20497d223e8f0e3c856c81/2a3d6/vnet-vxlan-20191107165758344.png 885w,\n/static/8eebca9b5c20497d223e8f0e3c856c81/3cdf1/vnet-vxlan-20191107165758344.png 1139w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>（图片来源：<a href=\"https://cizixs.com/2017/09/25/vxlan-protocol-introduction/\">vxlan协议原理简介</a>）</p>\n<p>从最内层往外看：最内层的Original L2 Frame是虚拟子网的二层数据包，在前面加上VXLAN的header。之后就被当作一个普通的udp包的payload，在真正的物理子网上发送出去。</p>\n<p>这里可以注意一下VXLAN Header中的VNID字段，共占24bit，所以VXLAN能够支持的不同子网共有<code class=\"language-text\">2^24 = 16777216</code>个。</p>\n<h4>组网原理</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 584px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b9243aa32a333bf609d27ccd5bc2c876/8abfd/5652c940898f4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.88356164383562%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACGElEQVQoz21STW/TQBDNb+HOhR/AHW6ICwcqcQBxCeIEiAPihFRBQfQEIqh89lAqEFFbGkFQQk0a0kKb4MaxG0IcJ3FTN7ZjpwqJ7c1jvXaUIDrS7M7uzLydfTMRTMhwOGTqi0uCPSXZOHFHxMmZXZg98l/cpO1LxF/IEQFeGJPgDRy7mcfx2wX8Vg0MiQtCxrGjnYR2ZBI9AKYB1O4PHPQsHctZCecf8bgQK0KsKOhaJrrdQwwc9x/Qkc0qrGh9tCxndA14f2C0Naiaic5hD7VmG5pho+cO6bmPbseArbdoBUFO0xygpg/GX57P6eDKNgN7v9nCy7U68lId7VIGe/wapI00dtY/o5pLQMisIpkT8CRRwmK2yXJW+Q6WCuYIkOBWvIk333XKjYcb7xo4N9fA4hcRldfXsTF7EamHUXy8H0V2ZgrfYtcwz8mYeq7gykLdJwoxTsODT/sMPLK1I6Mg1tBoGcGP+xZIZ485/Z4OKAM+W7726OKFtHimCjg2OynqAfKCDKGs0qYQgkShioK8D8dx8DRdxL2VbUiqERJNAl59DRuwLWu4u7KFF1yJFughS4FSQp35GYfTwk/EFRl9Cnh5M4OzX5PgtBZL9uiDo1FySTCHS00FZ7gkrv7I0gAPr6plPP4ljpuSrk+jqMXhui7e7l7CM/40atZ6OErexFgFtqR/wBx/CvFyFP6V2F4Gf7DAfH8BH+HcG9rQqYEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img\"\n        title=\"img\"\n        src=\"/static/b9243aa32a333bf609d27ccd5bc2c876/8abfd/5652c940898f4.png\"\n        srcset=\"/static/b9243aa32a333bf609d27ccd5bc2c876/00d96/5652c940898f4.png 148w,\n/static/b9243aa32a333bf609d27ccd5bc2c876/0b23c/5652c940898f4.png 295w,\n/static/b9243aa32a333bf609d27ccd5bc2c876/8abfd/5652c940898f4.png 584w\"\n        sizes=\"(max-width: 584px) 100vw, 584px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>（图片来源：<a href=\"https://cizixs.com/2017/09/25/vxlan-protocol-introduction/\">vxlan协议原理简介</a>）</p>\n<p>一个VXLAN网络中有几个重要的部分：</p>\n<ol>\n<li>VTEP，VXLAN Tunnel Endpoint。这个是每个机器上都会有一个VXLAN网络的endpoint，负责对数据包进行封包和解包。可以是软件实现，也可以是专有的硬件。</li>\n<li>VNI，区分不同VXLAN网络的标识符，这个主要是设置在每个VTEP上，VNI相同的VTEP在一个子网里。</li>\n</ol>\n<p>几台机器想要组成一个VXLAN，需要哪些信息？换句话说，假设已经有了一个VXLAN网络，在这个网络内的机器A想要给机器B发个数据包，有哪些地址字段需要填写？</p>\n<p>需要填写的字段有4个：</p>\n<ol>\n<li>内层（虚拟子网）的IP地址</li>\n<li>内层的MAC地址</li>\n<li>外层（物理子网）的IP地址</li>\n<li>外层的MAC地址</li>\n</ol>\n<p>A上的应用要给B发消息，肯定是知道B的IP地址（内层IP地址）；并且如果知道外层的IP地址，通过物理子网的arp可以知道外层的MAC。所以还缺少的地址有：</p>\n<ol>\n<li>内层（虚拟子网）的MAC地址</li>\n<li>外层（物理子网）的IP地址</li>\n</ol>\n<p>想要得到这两个信息，一般有组播和控制中心两种办法。</p>\n<ol>\n<li>组播是通过在组播地址上组播，VTEP自动学习着两个信息。这里先不展开介绍</li>\n<li>控制中心是通过一个中心数据库来提供这两个信息，比如在k8s中可以在创建pod的时候，把1. pod的MAC地址 2. pod所在机器的IP地址存储到etcd里，在后面别的机器（上的pod）需要和这个pod通信的时候，可以通过像etcd发起查询得到这两个信息，就可以通信了。</li>\n</ol>\n<h3>在linux中实践VXLAN</h3>\n<h4>目标</h4>\n<p>在2台机器上构建一个VXLAN，使机器&#x3C;==>机器，机器&#x3C;==>容器，容器&#x3C;==>容器之间都可以通信。</p>\n<h4>网络拓扑</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/12be2088c186b3768405cb0713bbedc6/77a09/expected-network-topography-vxlan.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.95852534562212%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAADb0lEQVQ4y62Ty2/cVBSHPeNpoIAQEumi4j9ALBCiWxY0BaEgVQ2QVKrSBRQEAkUsALHKkgXsYAEFReIhCmyAlEZQtWEmzXTs8bXv9WvG9jz8nlcaEiUlzDBOfbjXURA7WHClo3tk/86n87iHW3jvAjf36mnuzQ9e4g7PqekzE+z+pRo8Jje24IdrMoj1DVDatz9i308+/ezRY8cnc8xnseL2z9y30kXuK/FDjgOAPLNgO+btbpOfeubUvecvvHj0ldem+Mvl+gOivTW9ivzpSm3jtGBtP8wg31z+fuLJp07e987iuxMs1um2+Ginyxs9nef+93PD/vWLor76ndbDH99sri+Rjvyp3iOfaD3yuRyLU0xTqTcLotM6wvxqUH7jGr66IrnCkuSLn1W9ypLRVy9S+xLH0utca9eBcOSDv+NCs+eAt+tCbWBANApAaJWvMghuqTmtQwqZH6HiFmyCd7sN7VstcDfbYG/WqVlws7kGnBrjsdk3EiPUx8QhiR7pY9SWRlqsgeSKKwxCGgYDZv0hsfxje6cJtZ45VFvqWHe1seLJY6lZTcqNtRGndXDKMtI8NUUmAiPSU6ld3dcpEIcoA8oOydX65iHwir/nMmCi2DKQBk4VD6UUCJXmekozVFIqBtUnabUughHrIHtovz6ogxIcANU2yxAfApczYN9M5IYMSlMBNSQp9jGtSNg/AA4o0CWpQATQfBVYhmbPANmXlhkEWThHQf8AelmGVbMKUk0C2ZVS2UU0wxt7DHgnK89XUhxSo7fR0feDPR/0LrnCIN29wd89pENZ9n93gfgkwQHVU9NCNbU3bKBTvsORQAGRCGNkoMQa1BPak0RQhJHds0HtKBnQ/y3KIbeaAZVQ+snp2CDIlaEe6InVrycCFhIWjyN5yCkR+oP1kAQY3F36BG5ZQKcMnT9j0HtqiUFqnpVXXFQ4KBldCod+pnE2bYiGIWgRAVoVqF0ZuIpXepQ+znMl8/osjtEM6aCZkrn6AvKFcyisPHG4AHTFslsIisfXneJs2VmbpYDnqe65onl9jvZ2Zr21eua/LBN/bHIyf+LxE4XJhx7M/6taDsW8Huv8CIb5xfcXj8ydn7174a2Fe+ividJa8ZEwDHWMsWxZVisIgrdZzNn5s/cz3fzL83ddWvm6wGLVUOVRKPB/AWY1u8P1sZwsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img\"\n        title=\"img\"\n        src=\"/static/12be2088c186b3768405cb0713bbedc6/799d3/expected-network-topography-vxlan.png\"\n        srcset=\"/static/12be2088c186b3768405cb0713bbedc6/00d96/expected-network-topography-vxlan.png 148w,\n/static/12be2088c186b3768405cb0713bbedc6/0b23c/expected-network-topography-vxlan.png 295w,\n/static/12be2088c186b3768405cb0713bbedc6/799d3/expected-network-topography-vxlan.png 590w,\n/static/12be2088c186b3768405cb0713bbedc6/77a09/expected-network-topography-vxlan.png 651w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>（图片来源: <a href=\"https://github.com/yangyuqian/k8s-the-hard-way/blob/master/network/vxlan-flannel-cn.md\">VXLAN在Flannel中的Overlay网络的实现</a>）</p>\n<p>需要搭建的overlay子网为192.1.0.0/16。</p>\n<h4>步骤</h4>\n<ol>\n<li>创建VXLAN interface（VTEP），给VXLAN分配ip</li>\n<li>路由表新增一项，把虚拟子网的流量交给VTEP处理</li>\n<li>上面提到要打包缺少的地址：「内层（虚拟子网）的MAC地址」，这里通过手动修改ARP表实现。ARP表新增几项，把overlay网络上需要访问的容器（机器）ip地址都指向<strong>该机器的VTEP的MAC地址</strong>。</li>\n<li>另一个缺少的地址：「外层（物理子网）的IP地址」，通过修改转发表来实现。转发表新增一项，把发往VTEP MAC地址的流量都指向另一台机器的物理子网ip</li>\n</ol>\n<h4>一个数据包的奥德赛</h4>\n<p>经过这样的配置之后，一个数据包怎么从一个机器/容器路由到另一个机器/容器呢？这里选择讲解一个最长的路由路径：容器&#x3C;==>容器，其他情况都包含在这个路径里。\n假设node1上的容器A 192.1.78.2想要发一个数据包给node2上的容器B 192.1.87.2</p>\n<ol>\n<li>数据包从A发出，通过docker bridge来到docker0 interface，docker0需要知道该把这个数据包发给谁，于是他查询了路由表，发现命中了这条规则<code class=\"language-text\">192.1.0.0/16</code>，于是发往vxlan.1 interface。</li>\n<li>\n<p>vxlan.1收到数据包之后开始打包，需要填写4个地址：</p>\n<blockquote>\n<ol>\n<li>内层（虚拟子网）的IP地址</li>\n<li>内层的MAC地址</li>\n<li>外层（物理子网）的IP地址</li>\n<li>外层的MAC地址</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<p>1 已知；2 会通过arp请求去查找，命中前面手动维护的本地arp缓存，得到node2 VTEP的MAC地址；3 会命中手动维护的fdb转发表，得到node2的物理子网IP地址；4 通过物理子网arp得到。</p>\n<ol start=\"3\">\n<li>打包完成后，得到一个物理子网的普通udp包发往node2的4789端口。node2的vxlan.1 interface监听该端口，接到udp包之后解开封装得到内层的数据包。</li>\n<li>vxlan.1需要知道数据包该发往哪里，同样查询本机的路由表，命中<code class=\"language-text\">192.1.87.0/24</code>，发往docker0 interface。docker0再将数据包发给容器B。</li>\n</ol>\n<h4>实践</h4>\n<h5>1. 实现机器&#x3C;==>机器通信</h5>\n<p>将以上步骤写到一起，方便执行：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># step1</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">IP</span><span class=\"token operator\">=</span> <span class=\"token comment\"># 本机ip</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">DEST_IP</span><span class=\"token operator\">=</span> <span class=\"token comment\"># 另一台机器ip</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">VTEP_IP</span><span class=\"token operator\">=</span> <span class=\"token comment\"># 本机VTEP ip</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">PREFIX</span><span class=\"token operator\">=</span>vxlan\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">PORT</span><span class=\"token operator\">=</span><span class=\"token number\">4789</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">VNI</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">SUBNET</span><span class=\"token operator\">=</span><span class=\"token number\">192</span>.<span class=\"token variable\">$VNI</span>.0.0/16\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">DEVICE_NAME</span><span class=\"token operator\">=</span><span class=\"token variable\">$PREFIX</span><span class=\"token builtin class-name\">.</span><span class=\"token variable\">$VNI</span>\n\n<span class=\"token function\">ip</span> <span class=\"token function\">link</span> <span class=\"token function\">add</span> <span class=\"token variable\">$DEVICE_NAME</span> <span class=\"token builtin class-name\">type</span> vxlan <span class=\"token function\">id</span> <span class=\"token variable\">$VNI</span> dev eth0 dstport <span class=\"token variable\">$PORT</span> nolearning\n<span class=\"token function\">ip</span> address <span class=\"token function\">add</span> <span class=\"token variable\">$VTEP_IP</span> dev <span class=\"token variable\">$DEVICE_NAME</span>\n<span class=\"token function\">ip</span> <span class=\"token function\">link</span> <span class=\"token builtin class-name\">set</span> <span class=\"token variable\">$DEVICE_NAME</span> up \n<span class=\"token function\">ip</span> route <span class=\"token function\">add</span> <span class=\"token variable\">$SUBNET</span> dev <span class=\"token variable\">$DEVICE_NAME</span> scope global\n\n<span class=\"token comment\"># step2 需要拿到step1的结果后在再进行</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ANOTHER_VTEP_MAC</span><span class=\"token operator\">=</span> <span class=\"token comment\"># 需要等另一台机器的VXLAN设备创建之后，查看其MAC地址</span>\nbridge fdb <span class=\"token function\">add</span> <span class=\"token variable\">$ANOTHER_VTEP_MAC</span> dev <span class=\"token variable\">$DEVICE_NAME</span> dst <span class=\"token variable\">$DEST_IP</span>\n\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ANOTHER_NODE_IP</span><span class=\"token operator\">=</span> <span class=\"token comment\"># 需要访问的另一台机器上的（容器或机器）ip</span>\n<span class=\"token function\">ip</span> neighbor <span class=\"token function\">add</span> <span class=\"token variable\">$ANOTHER_NODE_IP</span> lladdr <span class=\"token variable\">$ANOTHER_VTEP_MAC</span> dev <span class=\"token variable\">$DEVICE_NAME</span></code></pre></div>\n<p>Node1:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b75473b2711743edf07bca9b402ad511/0fd75/image-20191223172234150.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.75188781014025%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAAsSAAALEgHS3X78AAACc0lEQVQ4y11TiW6jMBDlW5q2aQg3NrdtMNhcCSTpdrW7//8h+4A2jSo9oRFieMfMGP7f0XvvnUknchTNJSraMFMk11GhHVraRLxY8SP2Vvz6VRvur945t/ZJRVXP6lmoSyHPfiyBIKmBVzt5bKYWdaxotzX7/xZme9JpPcr21gwfMeu8uLICtjPp04E8H6NHvADfzNB81vagQqYJBGcqYl3Ke5rrY8AOXvbmZm9OiufBXWs3u2sB82nxfOlo2Yl6ZvWkxt9q+ID4rBwT0UOFG5UOEfBvhxxB7J30i/nWu1PrDNovFHziO5B7sVx6aOlGFWrTL57Xr8H5/Cjbl6oYZn6+Vt1NqBlpk1zRos2qcTEfVfgjODdy/O4xP+PgZBkfcjGik9dTwns0BGkNbcCPtHaASe+ZGfAAe1zNVXvjzZyJAVbBHKyECycVzoIStPAMO0huE29YIefNxOQZE+bqgoLVZyanVAwb/2b1Drz5ThvzAFVenUCOqEGOGlpMPz94+X4d0h5z8vIfc1qa4RANaJPdTXbvC38zQwuYgTBtoBwE26oC6IftT9nIEMOE1LXnkxZPWuggbdADX7CKzOHcJhzA8PA79BuWz7AbvJ6xmxs5VKSi30he4BNS4RP1CtRYuP0q3jjELFFjUg+5PMW8By3Gm/AOntcbio4msUzimcQxiWuGe5NA9qbc8HEVQ7PtdpS3OVaS9zCSbUWQl5QXRDDCBBUyFmkiLSKQBdbG8E7tUcmjrLy0xiv4xElgQ1HgHsOs8XPlpY2fKRO3vWa+7Q9geH9G7/Z5GMgJhkt9rfQVBfhLfSmX/KeiOkFUpS8wdV/v/yei7yQvyITXAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20191223172234150\"\n        title=\"image-20191223172234150\"\n        src=\"/static/b75473b2711743edf07bca9b402ad511/799d3/image-20191223172234150.png\"\n        srcset=\"/static/b75473b2711743edf07bca9b402ad511/00d96/image-20191223172234150.png 148w,\n/static/b75473b2711743edf07bca9b402ad511/0b23c/image-20191223172234150.png 295w,\n/static/b75473b2711743edf07bca9b402ad511/799d3/image-20191223172234150.png 590w,\n/static/b75473b2711743edf07bca9b402ad511/2a3d6/image-20191223172234150.png 885w,\n/static/b75473b2711743edf07bca9b402ad511/ae92f/image-20191223172234150.png 1180w,\n/static/b75473b2711743edf07bca9b402ad511/0fd75/image-20191223172234150.png 1854w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Node2 :</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/594f065dc1585d6f878c52683ea095b8/df3b2/image-20191223172531204.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.02906350914962%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAACX0lEQVQ4y1VTCXKjMBDkKZs4F5c4BQIJJC5z+kw2qf3/R7YFjjdb1TWlstXTM93C8L5m/8/inoe0XWR3psVARR/xPSpJKpeqJyf9id2K7WyQ80jOgzPvYzWK5iTak2iOXlKRRAWs8Vnz7LKfTOJQx6Eb39DKX/OmXA3vzfTJyslPayeWDxb99Rbt7OQGi6LaNjU3sp0YoJHrCOWg7MOsC/meyYmpORa9E5VmIN68/NXnr16Os+nzFy/fbbOATD4nwL0MkRp4dcirQz1+AOCjCzbH2uhiR6UVFqhuLF9I9k2+jN77RJY+rgYMnJaj7K+ZmoG8WsCHBWHe4fYzyUDD5DcLNLlo8uFYLteyv8j9JZVzKkeA1wcwYRhsg/gd//wD+dXNWDFiYG11c4SyGysYtt14MGPg0aJ3/KeMq5iw7C4ActIDVwsVQ5i1a87yron8nBi1hoW6BchWUECw6M4go4JftDrtpBwxM0zW266jrpWhPt/dRgBMzhz89sTXLnl9wMJ2WCAYiLx954QD6s3qm2FJBZ2yO6v+CsNwQF3nX1I5wectJLwZew0M5NvmIOPXBIZpTa2MeFARcpi3QdYi1Q3wnFAFgO+ltRUKPDjD8oSoj3dBHEDGwlDTE7psp5E9IWGXPWJb92aBJptC0nFmwyI6RHVqpt/oghWivNNu+zn10tRjjCTcZzzI3IDjtaA1LDBI35lNZSrlsirmPd4jtoAyLXp8nkmi0qyh+Cut4kSFkfCostbJsa9B8DY/JvfQh7KnvMf3sL3qmO8hnqo5UTMtx1gMftb6mfYPbm2e/QU0reFPJmRM5QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20191223172531204\"\n        title=\"image-20191223172531204\"\n        src=\"/static/594f065dc1585d6f878c52683ea095b8/799d3/image-20191223172531204.png\"\n        srcset=\"/static/594f065dc1585d6f878c52683ea095b8/00d96/image-20191223172531204.png 148w,\n/static/594f065dc1585d6f878c52683ea095b8/0b23c/image-20191223172531204.png 295w,\n/static/594f065dc1585d6f878c52683ea095b8/799d3/image-20191223172531204.png 590w,\n/static/594f065dc1585d6f878c52683ea095b8/2a3d6/image-20191223172531204.png 885w,\n/static/594f065dc1585d6f878c52683ea095b8/ae92f/image-20191223172531204.png 1180w,\n/static/594f065dc1585d6f878c52683ea095b8/df3b2/image-20191223172531204.png 1858w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>查看一下这样执行之后机器上的路由表、arp表、和fdb转发表的内容，这里以node1为例：</p>\n<p>路由表：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@VM-0-7-ubuntu:~<span class=\"token comment\"># ip route</span>\ndefault via <span class=\"token number\">172.17</span>.0.1 dev eth0 proto static\n<span class=\"token number\">172.17</span>.0.0/20 dev eth0 proto kernel scope <span class=\"token function\">link</span> src <span class=\"token number\">172.17</span>.0.7\n<span class=\"token number\">172.18</span>.0.0/16 dev docker0 proto kernel scope <span class=\"token function\">link</span> src <span class=\"token number\">172.18</span>.0.1 linkdown\n<span class=\"token number\">192.1</span>.0.0/16 dev vxlan.1</code></pre></div>\n<p><code class=\"language-text\">192.1.0.0/16 dev vxlan.1</code>这条规则指定了<code class=\"language-text\">192.1.0.0/16</code>这个子网的流量都会通过<code class=\"language-text\">vxlan.1</code>这个设备来处理。</p>\n<p>arp表：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@VM-0-7-ubuntu:~<span class=\"token comment\"># ip neighbor</span>\n<span class=\"token number\">192.1</span>.87.0 dev vxlan.1 lladdr d2:04:98:13:a7:aa PERMANENT\n<span class=\"token number\">172.17</span>.0.1 dev eth0 lladdr fe:ee:00:2e:16:9a REACHABLE\n<span class=\"token number\">172.17</span>.0.4 dev eth0 lladdr fe:ee:00:2e:16:9a STALE</code></pre></div>\n<p>在arp表中添加了我们需要访问的ip <code class=\"language-text\">192.1.87.0</code>的MAC地址（因为我们需要ping的node2的机器ip）。需要注意的是，如果等下需要访问node2容器的ip地址（比如<code class=\"language-text\">192.1.87.2</code>)，这里还需要添加一条记录。</p>\n<p>fdb转发表：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@VM-0-7-ubuntu:~<span class=\"token comment\"># bridge fdb</span>\n<span class=\"token number\">33</span>:33:00:00:00:01 dev eth0 self permanent\n01:00:5e:00:00:01 dev eth0 self permanent\n<span class=\"token number\">33</span>:33:ff:7b:75:85 dev eth0 self permanent\n01:80:c2:00:00:00 dev eth0 self permanent\n01:80:c2:00:00:03 dev eth0 self permanent\n01:80:c2:00:00:0e dev eth0 self permanent\n<span class=\"token number\">33</span>:33:00:00:00:01 dev docker0 self permanent\n01:00:5e:00:00:01 dev docker0 self permanent\n02:42:c0:52:69:49 dev docker0 vlan <span class=\"token number\">1</span> master docker0 permanent\n02:42:c0:52:69:49 dev docker0 master docker0 permanent\nd2:04:98:13:a7:aa dev vxlan.1 dst <span class=\"token number\">172.17</span>.0.4 self permanent</code></pre></div>\n<p>指定了发往<code class=\"language-text\">d2:04:98:13:a7:aa</code>这个MAC地址（node2 VTEP的MAC地址）的流量都发向<code class=\"language-text\">172.17.0.4</code>这个ip。</p>\n<p>这样就可以ping通两台机器了：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d97c5144bd758c68eee7f44af30edb81/03e06/image-20191223172718418.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 18.152524167561758%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAmklEQVQY043P2w6CMAwGYJ5GQFE5bGxjB0AYA3z/5/ndluCVMVw0bZr0a5sw60BHCzYsUGqF6XcovYHxCXXT41lq5FeGLG9PRSK4RScWCGHBfXTSQSrnwTnWYUHoX1KCNKNx6Mg/Qdk5aH+RUltEtNnQsgm0fYHQEWWlUdUGDRn+Ql+QLyvY7FH7hjF7HAzYAd4fMr58K8Qp8AP2Q4EFiqhsKQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20191223172718418\"\n        title=\"image-20191223172718418\"\n        src=\"/static/d97c5144bd758c68eee7f44af30edb81/799d3/image-20191223172718418.png\"\n        srcset=\"/static/d97c5144bd758c68eee7f44af30edb81/00d96/image-20191223172718418.png 148w,\n/static/d97c5144bd758c68eee7f44af30edb81/0b23c/image-20191223172718418.png 295w,\n/static/d97c5144bd758c68eee7f44af30edb81/799d3/image-20191223172718418.png 590w,\n/static/d97c5144bd758c68eee7f44af30edb81/2a3d6/image-20191223172718418.png 885w,\n/static/d97c5144bd758c68eee7f44af30edb81/ae92f/image-20191223172718418.png 1180w,\n/static/d97c5144bd758c68eee7f44af30edb81/03e06/image-20191223172718418.png 1862w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h5>2. 实现容器&#x3C;==>容器通信</h5>\n<p>有了前面机器&#x3C;==>机器的通信基础之后，容器&#x3C;==>容器就比较简单了。</p>\n<p>首先需要改一下docker的子网，修改docker的启动参数并重启docker：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cat</span> <span class=\"token operator\">></span> /etc/docker/daemon.json <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">EOF\n{\"bip\":\"192.1.78.1/24\"}\nEOF</span>\n\nsystemctl restart docker</code></pre></div>\n<p>然后启动docker容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker run -it --rm busybox</code></pre></div>\n<p>查看一下容器的ip地址：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">/ <span class=\"token comment\"># ip a</span>\n<span class=\"token number\">1</span>: lo: <span class=\"token operator\">&lt;</span>LOOPBACK,UP,LOWER_UP<span class=\"token operator\">></span> mtu <span class=\"token number\">65536</span> qdisc noqueue qlen <span class=\"token number\">1000</span>\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet <span class=\"token number\">127.0</span>.0.1/8 scope <span class=\"token function\">host</span> lo\n       valid_lft forever preferred_lft forever\n<span class=\"token number\">6</span>: eth0@if7: <span class=\"token operator\">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class=\"token operator\">></span> mtu <span class=\"token number\">1500</span> qdisc noqueue\n    link/ether 02:42:c0:01:4e:02 brd ff:ff:ff:ff:ff:ff\n    inet <span class=\"token number\">192.1</span>.78.2/24 brd <span class=\"token number\">192.1</span>.78.255 scope global eth0\n       valid_lft forever preferred_lft forever</code></pre></div>\n<p>在node2上面重复以上步骤（对应的子网地址需要改一下）。</p>\n<p>可以看到node1上container的ip是<code class=\"language-text\">192.1.78.2</code>，node2上的container的ip是<code class=\"language-text\">192.1.87.2</code>，所以需要在2台机器上分别添加这两个ip的arp记录：</p>\n<p>Node1:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ANOTHER_NODE_IP</span><span class=\"token operator\">=</span><span class=\"token number\">192.1</span>.87.2 <span class=\"token comment\"># 需要访问的另一台机器上的（容器或机器）ip</span>\n<span class=\"token function\">ip</span> neighbor <span class=\"token function\">add</span> <span class=\"token variable\">$ANOTHER_NODE_IP</span> lladdr <span class=\"token variable\">$ANOTHER_VTEP_MAC</span> dev <span class=\"token variable\">$DEVICE_NAME</span></code></pre></div>\n<p>Node2:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ANOTHER_NODE_IP</span><span class=\"token operator\">=</span><span class=\"token number\">192.1</span>.78.2 <span class=\"token comment\"># 需要访问的另一台机器上的（容器或机器）ip</span>\n<span class=\"token function\">ip</span> neighbor <span class=\"token function\">add</span> <span class=\"token variable\">$ANOTHER_NODE_IP</span> lladdr <span class=\"token variable\">$ANOTHER_VTEP_MAC</span> dev <span class=\"token variable\">$DEVICE_NAME</span></code></pre></div>\n<p>这样就可以ping通容器…了吗？并没有，这时候ping会发现是ping不通的。</p>\n<p>经过很长时间的摸索，我发现是docker设置的iptables的规则阻止了ping包:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@VM-0-4-ubuntu:~<span class=\"token comment\"># iptables -L -v</span>\nChain INPUT <span class=\"token punctuation\">(</span>policy ACCEPT <span class=\"token number\">1322</span> packets, 897K bytes<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n\nChain FORWARD <span class=\"token punctuation\">(</span>policy DROP <span class=\"token number\">10</span> packets, <span class=\"token number\">840</span> bytes<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n   <span class=\"token number\">10</span>   <span class=\"token number\">840</span> DOCKER-<span class=\"token environment constant\">USER</span>  all  --  any    any     anywhere             anywhere\n   <span class=\"token number\">10</span>   <span class=\"token number\">840</span> DOCKER-ISOLATION-STAGE-1  all  --  any    any     anywhere             anywhere\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> ACCEPT     all  --  any    docker0  anywhere             anywhere             ctstate RELATED,ESTABLISHED\n   <span class=\"token number\">10</span>   <span class=\"token number\">840</span> DOCKER     all  --  any    docker0  anywhere             anywhere\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> ACCEPT     all  --  docker0 <span class=\"token operator\">!</span>docker0  anywhere             anywhere\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> ACCEPT     all  --  docker0 docker0  anywhere             anywhere\n\nChain OUTPUT <span class=\"token punctuation\">(</span>policy ACCEPT <span class=\"token number\">1294</span> packets, 147K bytes<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n\nChain DOCKER <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> references<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n\nChain DOCKER-ISOLATION-STAGE-1 <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> references<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> DOCKER-ISOLATION-STAGE-2  all  --  docker0 <span class=\"token operator\">!</span>docker0  anywhere             anywhere\n   <span class=\"token number\">10</span>   <span class=\"token number\">840</span> RETURN     all  --  any    any     anywhere             anywhere\n\nChain DOCKER-ISOLATION-STAGE-2 <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> references<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> DROP       all  --  any    docker0  anywhere             anywhere\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> RETURN     all  --  any    any     anywhere             anywhere\n\nChain DOCKER-<span class=\"token environment constant\">USER</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> references<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n   <span class=\"token number\">10</span>   <span class=\"token number\">840</span> RETURN     all  --  any    any     anywhere             anywhere</code></pre></div>\n<p>iptables的<code class=\"language-text\">FORWARD</code>chain阻止了包从<code class=\"language-text\">vxlan.1</code> 到<code class=\"language-text\">docker0</code>interface的forward，所以导致ping不通。这里不细究<code class=\"language-text\">FORWARD</code>chain下的iptables规则，先简单直接地把<code class=\"language-text\">FORWARD</code>chain的默认policy设置为<code class=\"language-text\">ACCEPT</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iptables -P FORWARD ACCEPT</code></pre></div>\n<p>这样2个容器之间就可以ping通了：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/ae933/image-20191223192249290.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.720430107526884%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAhUlEQVQY042PSw6DMAxEc5vSUhWqAnF+hIqEoLDh/peZBkvdZ/H0ZC/GHmHSAb1n0JogdQBRwGdYmEmu6HqLWzOiuU9ViBhOzC4zxiSQjnBzmX2GX8qxsnu0VB0qlNn4E1k++3sYv+jfjn3RPhUH1iC8P2BsgnU7W+mNTSpy+FX51dnqyj/PH4DFquWXfAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20191223192249290\"\n        title=\"image-20191223192249290\"\n        src=\"/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/799d3/image-20191223192249290.png\"\n        srcset=\"/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/00d96/image-20191223192249290.png 148w,\n/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/0b23c/image-20191223192249290.png 295w,\n/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/799d3/image-20191223192249290.png 590w,\n/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/2a3d6/image-20191223192249290.png 885w,\n/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/ae92f/image-20191223192249290.png 1180w,\n/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/ae933/image-20191223192249290.png 1860w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>Flannel and VXLAN</h3>\n<p>Flannel和VXLAN有什么关系？</p>\n<p>Flannel采用搭建overlay网络的方法来满足<a href=\"https://kubernetes.io/docs/concepts/cluster-administration/networking/#the-kubernetes-network-model\">k8s的网络模型</a>，它提供了几个不通的backend来搭建overlay网络，其中VXLAN是最推荐的一个backend。VXLAN在linux内核中有良好支持，性能好。</p>\n<p>Flannel利用VXLAN来构建overlay网络，本身只维护几个表，其余工作都是VXLAN完成。基本原理和上面的手工操作是一样的，只是flannel把这个过程自动化了。</p>\n<p>Flannel一共迭代了3个版本：</p>\n<h4>第一版</h4>\n<p>每个机器上的flannel daemon会创建VXLAN interface，并把自己注册为L2MISS和L3MISS事件的handler。</p>\n<p>L2MISS是在2层网络的miss，也就是从IP查找MAC这一步的miss（对应上面的地址2）。Flannel daemon收到miss后会查找存储的数据来给出对应的MAC地址，并将其加入arp缓存。</p>\n<p>L3MISS是host不知道某个MAC地址应该发往哪里时产生的miss（对应上面的地址3）。收到miss后给出ip地址，并加入fdb。</p>\n<p>这个版本每个机器上需要有：</p>\n<ul>\n<li>1条路由表记录（指向VXLAN interface）</li>\n<li>每个最近通信过的container1条arp表记录</li>\n<li>每个主机1条fdb表记录</li>\n</ul>\n<h4>第二版</h4>\n<p>去掉L3MISS handler。每次新机器加入集群时，直接添加在所有主机上添加好所需的fdb记录。</p>\n<h4>第三版</h4>\n<p>去掉L2MISS handler。需要添加n-1条路由表记录，这些路由表记录和前面不同的是，除了将路由指向VXLAN interface，还指定了通过VXLAN之后下一跳的地址（对应主机的ip地址）。这样就只需要每个主机1条arp记录，以及每个主机1条fdb记录。</p>\n<p>这样flannel daemon就不需要监听任何内核的事件，只需要在机器加入、退出集群的时候维护好这些记录。即使flannel daemon挂了整个overlay网络还是能（在很长一段时间内）正常运行。</p>\n<h3>Reference</h3>\n<ol>\n<li><a href=\"https://github.com/yangyuqian/k8s-the-hard-way/blob/master/network/vxlan-flannel-cn.md\">vxlan在Flannel中的Overlay网络的实现</a></li>\n<li><a href=\"https://cizixs.com/2017/09/25/vxlan-protocol-introduction/\">vxlan协议原理简介</a></li>\n<li><a href=\"https://www.sdnlab.com/21143.html\">容器Flannel vxlan基本原理和验证</a></li>\n<li><a href=\"https://tools.ietf.org/html/rfc7348\">rfc7348</a></li>\n<li><a href=\"https://github.com/coreos/Flannel/blob/master/backend/vxlan/vxlan.go#L18\">Flannel design notes and history</a></li>\n</ol>","frontmatter":{"title":"VXLAN & Flannel","date":"December 23, 2019","description":"讲一点VXLAN，讲一点Flannel，讲一点VXLAN和Flannel的关系。顺便搭建一个简单的VXLAN网络"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/VXLAN & Flannel/Vxlan和Flannel/","previous":null,"next":null}}}