{"componentChunkName":"component---src-templates-blog-post-js","path":"/VXLAN&Flannel/","result":{"data":{"site":{"siteMetadata":{"title":"Mingxin"}},"markdownRemark":{"id":"f40115ab-086e-569d-ab3f-8bba74b30b13","excerpt":"VXLAN 是什么 Virtual Extensible LAN(VXLAN)是一个在三层网络上模拟二层网络的网络虚拟化技术。可以解决云计算场景下子网不够用的问题。 有一个和 VXLAN 名字和解决的问题都很相似的技术：VLAN，VXLAN 和 VLAN 相比的优点是什么？ 传统 VLAN 只能支持 400…","html":"<h3>VXLAN 是什么</h3>\n<p>Virtual Extensible LAN(VXLAN)是一个在三层网络上模拟二层网络的网络虚拟化技术。可以解决云计算场景下子网不够用的问题。</p>\n<p>有一个和 VXLAN 名字和解决的问题都很相似的技术：VLAN，VXLAN 和 VLAN 相比的优点是什么？</p>\n<p>传统 VLAN 只能支持 4000 个子网，VXLAN 可以支持 1600 万个子网。</p>\n<h3>VXLAN 原理</h3>\n<p>使用三层网络的 udp 包来封装二层的数据包。</p>\n<h4>包结构</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8eebca9b5c20497d223e8f0e3c856c81/3cdf1/vnet-vxlan-20191107165758344.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.410008779631255%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAACf0lEQVQoz02RXUjTARTF11sPFRG99hYUPRRGWA8VPvYiRJbWjIr8SkijILEQ8yOtLPPBItDCraVrzpXOrTl1S3OburkP59x0m7ql07CVaTl1hb/+Sg9dOJzDvdzDuVzR4KANq20Iu8PFx85OBu7fYKQyH3PFLZofldL8uJyWqlKUG/phidArQfGPN+aKiiK0tVWY+gdxu0cQOZwu7HYn9mEPZr2OSMo+SN+PLeUgOxu8bFMvsqPWzJmsfMSZuZTXPGc0FGHAM86If5I2h58XxXewC6E8oz5E/YLzJqx2utta8aYe4seVI1jSEkmqlHG0pp2ke3VkZ+aQl51DZUkpGpUKlVyORqnkleQNL+/exCJ4uFxuRKFQGK/Xx7g/QMDvZ8SgY6hdibtLw1jHe6zK1/gEtuk1dDbL0b9tRNsoRa9opEMuo6tJiuWDWtgPMjMzgwih4mtrRCIRlpaWiK/D4kqcxd/rRGNxwtEFvq/9YWk1zmpsmYXoPCu/fvJ/La+uEovFNrUoGAwSCATw+Xy4h4fxeEYJOIcImw1MmLoZM+oI9uqZ9Q4zODmLxhVAPeSj1T6GNziJxWTCJMBgMAr7wslWq43ubiNdAnqMPRgtVryyZ8ykJxBOP8z05WOETu8lWl/GKeNXtkgm2N40xa6WOeq7+snNuEpmTi5i8UWeVD9FZDJZ0Gh1qNUatO1a1J1GPNJa5i4l8lkwm844SfjsAb41PCC5J8pW2RS75SH2vPuCxGjlenY2GVnXSE27QPWGocPhpKf3E319QnQBZpuD8XYFwdvn8Becx18oxpeXzLyqjnzLHAmKUU6oxjjeNoHK7KCsqIhi4fMFBYVIJFL+AppxJ65sXr/CAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img\"\n        title=\"img\"\n        src=\"/static/8eebca9b5c20497d223e8f0e3c856c81/799d3/vnet-vxlan-20191107165758344.png\"\n        srcset=\"/static/8eebca9b5c20497d223e8f0e3c856c81/00d96/vnet-vxlan-20191107165758344.png 148w,\n/static/8eebca9b5c20497d223e8f0e3c856c81/0b23c/vnet-vxlan-20191107165758344.png 295w,\n/static/8eebca9b5c20497d223e8f0e3c856c81/799d3/vnet-vxlan-20191107165758344.png 590w,\n/static/8eebca9b5c20497d223e8f0e3c856c81/2a3d6/vnet-vxlan-20191107165758344.png 885w,\n/static/8eebca9b5c20497d223e8f0e3c856c81/3cdf1/vnet-vxlan-20191107165758344.png 1139w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>（图片来源：<a href=\"https://cizixs.com/2017/09/25/vxlan-protocol-introduction/\">vxlan 协议原理简介</a>）</p>\n<p>从最内层往外看：最内层的 Original L2 Frame 是虚拟子网的二层数据包，在前面加上 VXLAN 的 header。之后就被当作一个普通的 udp 包的 payload，在真正的物理子网上发送出去。</p>\n<p>这里可以注意一下 VXLAN Header 中的 VNID 字段，共占 24bit，所以 VXLAN 能够支持的不同子网共有<code class=\"language-text\">2^24 = 16777216</code>个。</p>\n<h4>组网原理</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 584px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b9243aa32a333bf609d27ccd5bc2c876/8abfd/5652c940898f4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.88356164383562%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACGElEQVQoz21STW/TQBDNb+HOhR/AHW6ICwcqcQBxCeIEiAPihFRBQfQEIqh89lAqEFFbGkFQQk0a0kKb4MaxG0IcJ3FTN7ZjpwqJ7c1jvXaUIDrS7M7uzLydfTMRTMhwOGTqi0uCPSXZOHFHxMmZXZg98l/cpO1LxF/IEQFeGJPgDRy7mcfx2wX8Vg0MiQtCxrGjnYR2ZBI9AKYB1O4PHPQsHctZCecf8bgQK0KsKOhaJrrdQwwc9x/Qkc0qrGh9tCxndA14f2C0Naiaic5hD7VmG5pho+cO6bmPbseArbdoBUFO0xygpg/GX57P6eDKNgN7v9nCy7U68lId7VIGe/wapI00dtY/o5pLQMisIpkT8CRRwmK2yXJW+Q6WCuYIkOBWvIk333XKjYcb7xo4N9fA4hcRldfXsTF7EamHUXy8H0V2ZgrfYtcwz8mYeq7gykLdJwoxTsODT/sMPLK1I6Mg1tBoGcGP+xZIZ485/Z4OKAM+W7726OKFtHimCjg2OynqAfKCDKGs0qYQgkShioK8D8dx8DRdxL2VbUiqERJNAl59DRuwLWu4u7KFF1yJFughS4FSQp35GYfTwk/EFRl9Cnh5M4OzX5PgtBZL9uiDo1FySTCHS00FZ7gkrv7I0gAPr6plPP4ljpuSrk+jqMXhui7e7l7CM/40atZ6OErexFgFtqR/wBx/CvFyFP6V2F4Gf7DAfH8BH+HcG9rQqYEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img\"\n        title=\"img\"\n        src=\"/static/b9243aa32a333bf609d27ccd5bc2c876/8abfd/5652c940898f4.png\"\n        srcset=\"/static/b9243aa32a333bf609d27ccd5bc2c876/00d96/5652c940898f4.png 148w,\n/static/b9243aa32a333bf609d27ccd5bc2c876/0b23c/5652c940898f4.png 295w,\n/static/b9243aa32a333bf609d27ccd5bc2c876/8abfd/5652c940898f4.png 584w\"\n        sizes=\"(max-width: 584px) 100vw, 584px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>（图片来源：<a href=\"https://cizixs.com/2017/09/25/vxlan-protocol-introduction/\">vxlan 协议原理简介</a>）</p>\n<p>一个 VXLAN 网络中有几个重要的部分：</p>\n<ol>\n<li>VTEP，VXLAN Tunnel Endpoint。这个是每个机器上都会有一个 VXLAN 网络的 endpoint，负责对数据包进行封包和解包。可以是软件实现，也可以是专有的硬件。</li>\n<li>VNI，区分不同 VXLAN 网络的标识符，这个主要是设置在每个 VTEP 上，VNI 相同的 VTEP 在一个子网里。</li>\n</ol>\n<p>几台机器想要组成一个 VXLAN，需要哪些信息？换句话说，假设已经有了一个 VXLAN 网络，在这个网络内的机器 A 想要给机器 B 发个数据包，有哪些地址字段需要填写？</p>\n<p>需要填写的字段有 4 个：</p>\n<ol>\n<li>内层（虚拟子网）的 IP 地址</li>\n<li>内层的 MAC 地址</li>\n<li>外层（物理子网）的 IP 地址</li>\n<li>外层的 MAC 地址</li>\n</ol>\n<p>A 上的应用要给 B 发消息，肯定是知道 B 的 IP 地址（内层 IP 地址）；并且如果知道外层的 IP 地址，通过物理子网的 arp 可以知道外层的 MAC。所以还缺少的地址有：</p>\n<ol>\n<li>内层（虚拟子网）的 MAC 地址</li>\n<li>外层（物理子网）的 IP 地址</li>\n</ol>\n<p>想要得到这两个信息，一般有组播和控制中心两种办法。</p>\n<ol>\n<li>组播是通过在组播地址上组播，VTEP 自动学习着两个信息。这里先不展开介绍</li>\n<li>控制中心是通过一个中心数据库来提供这两个信息，比如在 k8s 中可以在创建 pod 的时候，把 1. pod 的 MAC 地址 2. pod 所在机器的 IP 地址存储到 etcd 里，在后面别的机器（上的 pod）需要和这个 pod 通信的时候，可以通过像 etcd 发起查询得到这两个信息，就可以通信了。</li>\n</ol>\n<h3>在 linux 中实践 VXLAN</h3>\n<h4>目标</h4>\n<p>在 2 台机器上构建一个 VXLAN，使机器&#x3C;==>机器，机器&#x3C;==>容器，容器&#x3C;==>容器之间都可以通信。</p>\n<h4>网络拓扑</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/12be2088c186b3768405cb0713bbedc6/77a09/expected-network-topography-vxlan.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.95852534562212%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAADb0lEQVQ4y62Ty2/cVBSHPeNpoIAQEumi4j9ALBCiWxY0BaEgVQ2QVKrSBRQEAkUsALHKkgXsYAEFReIhCmyAlEZQtWEmzXTs8bXv9WvG9jz8nlcaEiUlzDBOfbjXURA7WHClo3tk/86n87iHW3jvAjf36mnuzQ9e4g7PqekzE+z+pRo8Jje24IdrMoj1DVDatz9i308+/ezRY8cnc8xnseL2z9y30kXuK/FDjgOAPLNgO+btbpOfeubUvecvvHj0ldem+Mvl+gOivTW9ivzpSm3jtGBtP8wg31z+fuLJp07e987iuxMs1um2+Ginyxs9nef+93PD/vWLor76ndbDH99sri+Rjvyp3iOfaD3yuRyLU0xTqTcLotM6wvxqUH7jGr66IrnCkuSLn1W9ypLRVy9S+xLH0utca9eBcOSDv+NCs+eAt+tCbWBANApAaJWvMghuqTmtQwqZH6HiFmyCd7sN7VstcDfbYG/WqVlws7kGnBrjsdk3EiPUx8QhiR7pY9SWRlqsgeSKKwxCGgYDZv0hsfxje6cJtZ45VFvqWHe1seLJY6lZTcqNtRGndXDKMtI8NUUmAiPSU6ld3dcpEIcoA8oOydX65iHwir/nMmCi2DKQBk4VD6UUCJXmekozVFIqBtUnabUughHrIHtovz6ogxIcANU2yxAfApczYN9M5IYMSlMBNSQp9jGtSNg/AA4o0CWpQATQfBVYhmbPANmXlhkEWThHQf8AelmGVbMKUk0C2ZVS2UU0wxt7DHgnK89XUhxSo7fR0feDPR/0LrnCIN29wd89pENZ9n93gfgkwQHVU9NCNbU3bKBTvsORQAGRCGNkoMQa1BPak0RQhJHds0HtKBnQ/y3KIbeaAZVQ+snp2CDIlaEe6InVrycCFhIWjyN5yCkR+oP1kAQY3F36BG5ZQKcMnT9j0HtqiUFqnpVXXFQ4KBldCod+pnE2bYiGIWgRAVoVqF0ZuIpXepQ+znMl8/osjtEM6aCZkrn6AvKFcyisPHG4AHTFslsIisfXneJs2VmbpYDnqe65onl9jvZ2Zr21eua/LBN/bHIyf+LxE4XJhx7M/6taDsW8Huv8CIb5xfcXj8ydn7174a2Fe+ividJa8ZEwDHWMsWxZVisIgrdZzNn5s/cz3fzL83ddWvm6wGLVUOVRKPB/AWY1u8P1sZwsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img\"\n        title=\"img\"\n        src=\"/static/12be2088c186b3768405cb0713bbedc6/799d3/expected-network-topography-vxlan.png\"\n        srcset=\"/static/12be2088c186b3768405cb0713bbedc6/00d96/expected-network-topography-vxlan.png 148w,\n/static/12be2088c186b3768405cb0713bbedc6/0b23c/expected-network-topography-vxlan.png 295w,\n/static/12be2088c186b3768405cb0713bbedc6/799d3/expected-network-topography-vxlan.png 590w,\n/static/12be2088c186b3768405cb0713bbedc6/77a09/expected-network-topography-vxlan.png 651w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>（图片来源: <a href=\"https://github.com/yangyuqian/k8s-the-hard-way/blob/master/network/vxlan-flannel-cn.md\">VXLAN 在 Flannel 中的 Overlay 网络的实现</a>）</p>\n<p>需要搭建的 overlay 子网为 192.1.0.0/16。</p>\n<h4>步骤</h4>\n<ol>\n<li>创建 VXLAN interface（VTEP），给 VXLAN 分配 ip</li>\n<li>路由表新增一项，把虚拟子网的流量交给 VTEP 处理</li>\n<li>上面提到要打包缺少的地址：「内层（虚拟子网）的 MAC 地址」，这里通过手动修改 ARP 表实现。ARP 表新增几项，把 overlay 网络上需要访问的容器（机器）ip 地址都指向<strong>该机器的 VTEP 的 MAC 地址</strong>。</li>\n<li>另一个缺少的地址：「外层（物理子网）的 IP 地址」，通过修改转发表来实现。转发表新增一项，把发往 VTEP MAC 地址的流量都指向另一台机器的物理子网 ip</li>\n</ol>\n<h4>一个数据包的奥德赛</h4>\n<p>经过这样的配置之后，一个数据包怎么从一个机器/容器路由到另一个机器/容器呢？这里选择讲解一个最长的路由路径：容器&#x3C;==>容器，其他情况都包含在这个路径里。\n假设 node1 上的容器 A 192.1.78.2 想要发一个数据包给 node2 上的容器 B 192.1.87.2</p>\n<ol>\n<li>数据包从 A 发出，通过 docker bridge 来到 docker0 interface，docker0 需要知道该把这个数据包发给谁，于是他查询了路由表，发现命中了这条规则<code class=\"language-text\">192.1.0.0/16</code>，于是发往 vxlan.1 interface。</li>\n<li>\n<p>vxlan.1 收到数据包之后开始打包，需要填写 4 个地址：</p>\n<blockquote>\n<ol>\n<li>内层（虚拟子网）的 IP 地址</li>\n<li>内层的 MAC 地址</li>\n<li>外层（物理子网）的 IP 地址</li>\n<li>外层的 MAC 地址</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<p>1 已知；2 会通过 arp 请求去查找，命中前面手动维护的本地 arp 缓存，得到 node2 VTEP 的 MAC 地址；3 会命中手动维护的 fdb 转发表，得到 node2 的物理子网 IP 地址；4 通过物理子网 arp 得到。</p>\n<ol start=\"3\">\n<li>打包完成后，得到一个物理子网的普通 udp 包发往 node2 的 4789 端口。node2 的 vxlan.1 interface 监听该端口，接到 udp 包之后解开封装得到内层的数据包。</li>\n<li>vxlan.1 需要知道数据包该发往哪里，同样查询本机的路由表，命中<code class=\"language-text\">192.1.87.0/24</code>，发往 docker0 interface。docker0 再将数据包发给容器 B。</li>\n</ol>\n<h4>实践</h4>\n<h5>1. 实现机器&#x3C;==>机器通信</h5>\n<p>将以上步骤写到一起，方便执行：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># step1</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">IP</span><span class=\"token operator\">=</span> <span class=\"token comment\"># 本机ip</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">DEST_IP</span><span class=\"token operator\">=</span> <span class=\"token comment\"># 另一台机器ip</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">VTEP_IP</span><span class=\"token operator\">=</span> <span class=\"token comment\"># 本机VTEP ip</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">PREFIX</span><span class=\"token operator\">=</span>vxlan\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">PORT</span><span class=\"token operator\">=</span><span class=\"token number\">4789</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">VNI</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">SUBNET</span><span class=\"token operator\">=</span><span class=\"token number\">192</span>.<span class=\"token variable\">$VNI</span>.0.0/16\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">DEVICE_NAME</span><span class=\"token operator\">=</span><span class=\"token variable\">$PREFIX</span><span class=\"token builtin class-name\">.</span><span class=\"token variable\">$VNI</span>\n\n<span class=\"token function\">ip</span> <span class=\"token function\">link</span> <span class=\"token function\">add</span> <span class=\"token variable\">$DEVICE_NAME</span> <span class=\"token builtin class-name\">type</span> vxlan <span class=\"token function\">id</span> <span class=\"token variable\">$VNI</span> dev eth0 dstport <span class=\"token variable\">$PORT</span> nolearning\n<span class=\"token function\">ip</span> address <span class=\"token function\">add</span> <span class=\"token variable\">$VTEP_IP</span> dev <span class=\"token variable\">$DEVICE_NAME</span>\n<span class=\"token function\">ip</span> <span class=\"token function\">link</span> <span class=\"token builtin class-name\">set</span> <span class=\"token variable\">$DEVICE_NAME</span> up\n<span class=\"token function\">ip</span> route <span class=\"token function\">add</span> <span class=\"token variable\">$SUBNET</span> dev <span class=\"token variable\">$DEVICE_NAME</span> scope global\n\n<span class=\"token comment\"># step2 需要拿到step1的结果后在再进行</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ANOTHER_VTEP_MAC</span><span class=\"token operator\">=</span> <span class=\"token comment\"># 需要等另一台机器的VXLAN设备创建之后，查看其MAC地址</span>\nbridge fdb <span class=\"token function\">add</span> <span class=\"token variable\">$ANOTHER_VTEP_MAC</span> dev <span class=\"token variable\">$DEVICE_NAME</span> dst <span class=\"token variable\">$DEST_IP</span>\n\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ANOTHER_NODE_IP</span><span class=\"token operator\">=</span> <span class=\"token comment\"># 需要访问的另一台机器上的（容器或机器）ip</span>\n<span class=\"token function\">ip</span> neighbor <span class=\"token function\">add</span> <span class=\"token variable\">$ANOTHER_NODE_IP</span> lladdr <span class=\"token variable\">$ANOTHER_VTEP_MAC</span> dev <span class=\"token variable\">$DEVICE_NAME</span></code></pre></div>\n<p>Node1:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b75473b2711743edf07bca9b402ad511/0fd75/image-20191223172234150.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.75188781014025%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAAsSAAALEgHS3X78AAACc0lEQVQ4y11TiW6jMBDlW5q2aQg3NrdtMNhcCSTpdrW7//8h+4A2jSo9oRFieMfMGP7f0XvvnUknchTNJSraMFMk11GhHVraRLxY8SP2Vvz6VRvur945t/ZJRVXP6lmoSyHPfiyBIKmBVzt5bKYWdaxotzX7/xZme9JpPcr21gwfMeu8uLICtjPp04E8H6NHvADfzNB81vagQqYJBGcqYl3Ke5rrY8AOXvbmZm9OiufBXWs3u2sB82nxfOlo2Yl6ZvWkxt9q+ID4rBwT0UOFG5UOEfBvhxxB7J30i/nWu1PrDNovFHziO5B7sVx6aOlGFWrTL57Xr8H5/Cjbl6oYZn6+Vt1NqBlpk1zRos2qcTEfVfgjODdy/O4xP+PgZBkfcjGik9dTwns0BGkNbcCPtHaASe+ZGfAAe1zNVXvjzZyJAVbBHKyECycVzoIStPAMO0huE29YIefNxOQZE+bqgoLVZyanVAwb/2b1Drz5ThvzAFVenUCOqEGOGlpMPz94+X4d0h5z8vIfc1qa4RANaJPdTXbvC38zQwuYgTBtoBwE26oC6IftT9nIEMOE1LXnkxZPWuggbdADX7CKzOHcJhzA8PA79BuWz7AbvJ6xmxs5VKSi30he4BNS4RP1CtRYuP0q3jjELFFjUg+5PMW8By3Gm/AOntcbio4msUzimcQxiWuGe5NA9qbc8HEVQ7PtdpS3OVaS9zCSbUWQl5QXRDDCBBUyFmkiLSKQBdbG8E7tUcmjrLy0xiv4xElgQ1HgHsOs8XPlpY2fKRO3vWa+7Q9geH9G7/Z5GMgJhkt9rfQVBfhLfSmX/KeiOkFUpS8wdV/v/yei7yQvyITXAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20191223172234150\"\n        title=\"image-20191223172234150\"\n        src=\"/static/b75473b2711743edf07bca9b402ad511/799d3/image-20191223172234150.png\"\n        srcset=\"/static/b75473b2711743edf07bca9b402ad511/00d96/image-20191223172234150.png 148w,\n/static/b75473b2711743edf07bca9b402ad511/0b23c/image-20191223172234150.png 295w,\n/static/b75473b2711743edf07bca9b402ad511/799d3/image-20191223172234150.png 590w,\n/static/b75473b2711743edf07bca9b402ad511/2a3d6/image-20191223172234150.png 885w,\n/static/b75473b2711743edf07bca9b402ad511/ae92f/image-20191223172234150.png 1180w,\n/static/b75473b2711743edf07bca9b402ad511/0fd75/image-20191223172234150.png 1854w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Node2 :</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/594f065dc1585d6f878c52683ea095b8/df3b2/image-20191223172531204.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.02906350914962%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAACX0lEQVQ4y1VTCXKjMBDkKZs4F5c4BQIJJC5z+kw2qf3/R7YFjjdb1TWlstXTM93C8L5m/8/inoe0XWR3psVARR/xPSpJKpeqJyf9id2K7WyQ80jOgzPvYzWK5iTak2iOXlKRRAWs8Vnz7LKfTOJQx6Eb39DKX/OmXA3vzfTJyslPayeWDxb99Rbt7OQGi6LaNjU3sp0YoJHrCOWg7MOsC/meyYmpORa9E5VmIN68/NXnr16Os+nzFy/fbbOATD4nwL0MkRp4dcirQz1+AOCjCzbH2uhiR6UVFqhuLF9I9k2+jN77RJY+rgYMnJaj7K+ZmoG8WsCHBWHe4fYzyUDD5DcLNLlo8uFYLteyv8j9JZVzKkeA1wcwYRhsg/gd//wD+dXNWDFiYG11c4SyGysYtt14MGPg0aJ3/KeMq5iw7C4ActIDVwsVQ5i1a87yron8nBi1hoW6BchWUECw6M4go4JftDrtpBwxM0zW266jrpWhPt/dRgBMzhz89sTXLnl9wMJ2WCAYiLx954QD6s3qm2FJBZ2yO6v+CsNwQF3nX1I5wectJLwZew0M5NvmIOPXBIZpTa2MeFARcpi3QdYi1Q3wnFAFgO+ltRUKPDjD8oSoj3dBHEDGwlDTE7psp5E9IWGXPWJb92aBJptC0nFmwyI6RHVqpt/oghWivNNu+zn10tRjjCTcZzzI3IDjtaA1LDBI35lNZSrlsirmPd4jtoAyLXp8nkmi0qyh+Cut4kSFkfCostbJsa9B8DY/JvfQh7KnvMf3sL3qmO8hnqo5UTMtx1gMftb6mfYPbm2e/QU0reFPJmRM5QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20191223172531204\"\n        title=\"image-20191223172531204\"\n        src=\"/static/594f065dc1585d6f878c52683ea095b8/799d3/image-20191223172531204.png\"\n        srcset=\"/static/594f065dc1585d6f878c52683ea095b8/00d96/image-20191223172531204.png 148w,\n/static/594f065dc1585d6f878c52683ea095b8/0b23c/image-20191223172531204.png 295w,\n/static/594f065dc1585d6f878c52683ea095b8/799d3/image-20191223172531204.png 590w,\n/static/594f065dc1585d6f878c52683ea095b8/2a3d6/image-20191223172531204.png 885w,\n/static/594f065dc1585d6f878c52683ea095b8/ae92f/image-20191223172531204.png 1180w,\n/static/594f065dc1585d6f878c52683ea095b8/df3b2/image-20191223172531204.png 1858w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>查看一下这样执行之后机器上的路由表、arp 表、和 fdb 转发表的内容，这里以 node1 为例：</p>\n<p>路由表：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@VM-0-7-ubuntu:~<span class=\"token comment\"># ip route</span>\ndefault via <span class=\"token number\">172.17</span>.0.1 dev eth0 proto static\n<span class=\"token number\">172.17</span>.0.0/20 dev eth0 proto kernel scope <span class=\"token function\">link</span> src <span class=\"token number\">172.17</span>.0.7\n<span class=\"token number\">172.18</span>.0.0/16 dev docker0 proto kernel scope <span class=\"token function\">link</span> src <span class=\"token number\">172.18</span>.0.1 linkdown\n<span class=\"token number\">192.1</span>.0.0/16 dev vxlan.1</code></pre></div>\n<p><code class=\"language-text\">192.1.0.0/16 dev vxlan.1</code>这条规则指定了<code class=\"language-text\">192.1.0.0/16</code>这个子网的流量都会通过<code class=\"language-text\">vxlan.1</code>这个设备来处理。</p>\n<p>arp 表：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@VM-0-7-ubuntu:~<span class=\"token comment\"># ip neighbor</span>\n<span class=\"token number\">192.1</span>.87.0 dev vxlan.1 lladdr d2:04:98:13:a7:aa PERMANENT\n<span class=\"token number\">172.17</span>.0.1 dev eth0 lladdr fe:ee:00:2e:16:9a REACHABLE\n<span class=\"token number\">172.17</span>.0.4 dev eth0 lladdr fe:ee:00:2e:16:9a STALE</code></pre></div>\n<p>在 arp 表中添加了我们需要访问的 ip <code class=\"language-text\">192.1.87.0</code>的 MAC 地址（因为我们需要 ping 的 node2 的机器 ip）。需要注意的是，如果等下需要访问 node2 容器的 ip 地址（比如<code class=\"language-text\">192.1.87.2</code>)，这里还需要添加一条记录。</p>\n<p>fdb 转发表：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@VM-0-7-ubuntu:~<span class=\"token comment\"># bridge fdb</span>\n<span class=\"token number\">33</span>:33:00:00:00:01 dev eth0 self permanent\n01:00:5e:00:00:01 dev eth0 self permanent\n<span class=\"token number\">33</span>:33:ff:7b:75:85 dev eth0 self permanent\n01:80:c2:00:00:00 dev eth0 self permanent\n01:80:c2:00:00:03 dev eth0 self permanent\n01:80:c2:00:00:0e dev eth0 self permanent\n<span class=\"token number\">33</span>:33:00:00:00:01 dev docker0 self permanent\n01:00:5e:00:00:01 dev docker0 self permanent\n02:42:c0:52:69:49 dev docker0 vlan <span class=\"token number\">1</span> master docker0 permanent\n02:42:c0:52:69:49 dev docker0 master docker0 permanent\nd2:04:98:13:a7:aa dev vxlan.1 dst <span class=\"token number\">172.17</span>.0.4 self permanent</code></pre></div>\n<p>指定了发往<code class=\"language-text\">d2:04:98:13:a7:aa</code>这个 MAC 地址（node2 VTEP 的 MAC 地址）的流量都发向<code class=\"language-text\">172.17.0.4</code>这个 ip。</p>\n<p>这样就可以 ping 通两台机器了：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d97c5144bd758c68eee7f44af30edb81/03e06/image-20191223172718418.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 18.152524167561758%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAmklEQVQY043P2w6CMAwGYJ5GQFE5bGxjB0AYA3z/5/ndluCVMVw0bZr0a5sw60BHCzYsUGqF6XcovYHxCXXT41lq5FeGLG9PRSK4RScWCGHBfXTSQSrnwTnWYUHoX1KCNKNx6Mg/Qdk5aH+RUltEtNnQsgm0fYHQEWWlUdUGDRn+Ql+QLyvY7FH7hjF7HAzYAd4fMr58K8Qp8AP2Q4EFiqhsKQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20191223172718418\"\n        title=\"image-20191223172718418\"\n        src=\"/static/d97c5144bd758c68eee7f44af30edb81/799d3/image-20191223172718418.png\"\n        srcset=\"/static/d97c5144bd758c68eee7f44af30edb81/00d96/image-20191223172718418.png 148w,\n/static/d97c5144bd758c68eee7f44af30edb81/0b23c/image-20191223172718418.png 295w,\n/static/d97c5144bd758c68eee7f44af30edb81/799d3/image-20191223172718418.png 590w,\n/static/d97c5144bd758c68eee7f44af30edb81/2a3d6/image-20191223172718418.png 885w,\n/static/d97c5144bd758c68eee7f44af30edb81/ae92f/image-20191223172718418.png 1180w,\n/static/d97c5144bd758c68eee7f44af30edb81/03e06/image-20191223172718418.png 1862w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h5>2. 实现容器&#x3C;==>容器通信</h5>\n<p>有了前面机器&#x3C;==>机器的通信基础之后，容器&#x3C;==>容器就比较简单了。</p>\n<p>首先需要改一下 docker 的子网，修改 docker 的启动参数并重启 docker：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cat</span> <span class=\"token operator\">></span> /etc/docker/daemon.json <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">EOF\n{\"bip\":\"192.1.78.1/24\"}\nEOF</span>\n\nsystemctl restart docker</code></pre></div>\n<p>然后启动 docker 容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker run -it --rm busybox</code></pre></div>\n<p>查看一下容器的 ip 地址：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">/ <span class=\"token comment\"># ip a</span>\n<span class=\"token number\">1</span>: lo: <span class=\"token operator\">&lt;</span>LOOPBACK,UP,LOWER_UP<span class=\"token operator\">></span> mtu <span class=\"token number\">65536</span> qdisc noqueue qlen <span class=\"token number\">1000</span>\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet <span class=\"token number\">127.0</span>.0.1/8 scope <span class=\"token function\">host</span> lo\n       valid_lft forever preferred_lft forever\n<span class=\"token number\">6</span>: eth0@if7: <span class=\"token operator\">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class=\"token operator\">></span> mtu <span class=\"token number\">1500</span> qdisc noqueue\n    link/ether 02:42:c0:01:4e:02 brd ff:ff:ff:ff:ff:ff\n    inet <span class=\"token number\">192.1</span>.78.2/24 brd <span class=\"token number\">192.1</span>.78.255 scope global eth0\n       valid_lft forever preferred_lft forever</code></pre></div>\n<p>在 node2 上面重复以上步骤（对应的子网地址需要改一下）。</p>\n<p>可以看到 node1 上 container 的 ip 是<code class=\"language-text\">192.1.78.2</code>，node2 上的 container 的 ip 是<code class=\"language-text\">192.1.87.2</code>，所以需要在 2 台机器上分别添加这两个 ip 的 arp 记录：</p>\n<p>Node1:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ANOTHER_NODE_IP</span><span class=\"token operator\">=</span><span class=\"token number\">192.1</span>.87.2 <span class=\"token comment\"># 需要访问的另一台机器上的（容器或机器）ip</span>\n<span class=\"token function\">ip</span> neighbor <span class=\"token function\">add</span> <span class=\"token variable\">$ANOTHER_NODE_IP</span> lladdr <span class=\"token variable\">$ANOTHER_VTEP_MAC</span> dev <span class=\"token variable\">$DEVICE_NAME</span></code></pre></div>\n<p>Node2:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">ANOTHER_NODE_IP</span><span class=\"token operator\">=</span><span class=\"token number\">192.1</span>.78.2 <span class=\"token comment\"># 需要访问的另一台机器上的（容器或机器）ip</span>\n<span class=\"token function\">ip</span> neighbor <span class=\"token function\">add</span> <span class=\"token variable\">$ANOTHER_NODE_IP</span> lladdr <span class=\"token variable\">$ANOTHER_VTEP_MAC</span> dev <span class=\"token variable\">$DEVICE_NAME</span></code></pre></div>\n<p>这样就可以 ping 通容器…了吗？并没有，这时候 ping 会发现是 ping 不通的。</p>\n<p>经过很长时间的摸索，我发现是 docker 设置的 iptables 的规则阻止了 ping 包:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@VM-0-4-ubuntu:~<span class=\"token comment\"># iptables -L -v</span>\nChain INPUT <span class=\"token punctuation\">(</span>policy ACCEPT <span class=\"token number\">1322</span> packets, 897K bytes<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n\nChain FORWARD <span class=\"token punctuation\">(</span>policy DROP <span class=\"token number\">10</span> packets, <span class=\"token number\">840</span> bytes<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n   <span class=\"token number\">10</span>   <span class=\"token number\">840</span> DOCKER-<span class=\"token environment constant\">USER</span>  all  --  any    any     anywhere             anywhere\n   <span class=\"token number\">10</span>   <span class=\"token number\">840</span> DOCKER-ISOLATION-STAGE-1  all  --  any    any     anywhere             anywhere\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> ACCEPT     all  --  any    docker0  anywhere             anywhere             ctstate RELATED,ESTABLISHED\n   <span class=\"token number\">10</span>   <span class=\"token number\">840</span> DOCKER     all  --  any    docker0  anywhere             anywhere\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> ACCEPT     all  --  docker0 <span class=\"token operator\">!</span>docker0  anywhere             anywhere\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> ACCEPT     all  --  docker0 docker0  anywhere             anywhere\n\nChain OUTPUT <span class=\"token punctuation\">(</span>policy ACCEPT <span class=\"token number\">1294</span> packets, 147K bytes<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n\nChain DOCKER <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> references<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n\nChain DOCKER-ISOLATION-STAGE-1 <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> references<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> DOCKER-ISOLATION-STAGE-2  all  --  docker0 <span class=\"token operator\">!</span>docker0  anywhere             anywhere\n   <span class=\"token number\">10</span>   <span class=\"token number\">840</span> RETURN     all  --  any    any     anywhere             anywhere\n\nChain DOCKER-ISOLATION-STAGE-2 <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> references<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> DROP       all  --  any    docker0  anywhere             anywhere\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> RETURN     all  --  any    any     anywhere             anywhere\n\nChain DOCKER-<span class=\"token environment constant\">USER</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> references<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination\n   <span class=\"token number\">10</span>   <span class=\"token number\">840</span> RETURN     all  --  any    any     anywhere             anywhere</code></pre></div>\n<p>iptables 的<code class=\"language-text\">FORWARD</code>chain 阻止了包从<code class=\"language-text\">vxlan.1</code> 到<code class=\"language-text\">docker0</code>interface 的 forward，所以导致 ping 不通。这里不细究<code class=\"language-text\">FORWARD</code>chain 下的 iptables 规则，先简单直接地把<code class=\"language-text\">FORWARD</code>chain 的默认 policy 设置为<code class=\"language-text\">ACCEPT</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iptables -P FORWARD ACCEPT</code></pre></div>\n<p>这样 2 个容器之间就可以 ping 通了：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/ae933/image-20191223192249290.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.720430107526884%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAhUlEQVQY042PSw6DMAxEc5vSUhWqAnF+hIqEoLDh/peZBkvdZ/H0ZC/GHmHSAb1n0JogdQBRwGdYmEmu6HqLWzOiuU9ViBhOzC4zxiSQjnBzmX2GX8qxsnu0VB0qlNn4E1k++3sYv+jfjn3RPhUH1iC8P2BsgnU7W+mNTSpy+FX51dnqyj/PH4DFquWXfAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20191223192249290\"\n        title=\"image-20191223192249290\"\n        src=\"/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/799d3/image-20191223192249290.png\"\n        srcset=\"/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/00d96/image-20191223192249290.png 148w,\n/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/0b23c/image-20191223192249290.png 295w,\n/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/799d3/image-20191223192249290.png 590w,\n/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/2a3d6/image-20191223192249290.png 885w,\n/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/ae92f/image-20191223192249290.png 1180w,\n/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/ae933/image-20191223192249290.png 1860w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>Flannel and VXLAN</h3>\n<p>Flannel 和 VXLAN 有什么关系？</p>\n<p>Flannel 采用搭建 overlay 网络的方法来满足<a href=\"https://kubernetes.io/docs/concepts/cluster-administration/networking/#the-kubernetes-network-model\">k8s 的网络模型</a>，它提供了几个不通的 backend 来搭建 overlay 网络，其中 VXLAN 是最推荐的一个 backend。VXLAN 在 linux 内核中有良好支持，性能好。</p>\n<p>Flannel 利用 VXLAN 来构建 overlay 网络，本身只维护几个表，其余工作都是 VXLAN 完成。基本原理和上面的手工操作是一样的，只是 flannel 把这个过程自动化了。</p>\n<p>Flannel 一共迭代了 3 个版本：</p>\n<h4>第一版</h4>\n<p>每个机器上的 flannel daemon 会创建 VXLAN interface，并把自己注册为 L2MISS 和 L3MISS 事件的 handler。</p>\n<p>L2MISS 是在 2 层网络的 miss，也就是从 IP 查找 MAC 这一步的 miss（对应上面的地址 2）。Flannel daemon 收到 miss 后会查找存储的数据来给出对应的 MAC 地址，并将其加入 arp 缓存。</p>\n<p>L3MISS 是 host 不知道某个 MAC 地址应该发往哪里时产生的 miss（对应上面的地址 3）。收到 miss 后给出 ip 地址，并加入 fdb。</p>\n<p>这个版本每个机器上需要有：</p>\n<ul>\n<li>1 条路由表记录（指向 VXLAN interface）</li>\n<li>每个最近通信过的 container1 条 arp 表记录</li>\n<li>每个主机 1 条 fdb 表记录</li>\n</ul>\n<h4>第二版</h4>\n<p>去掉 L3MISS handler。每次新机器加入集群时，直接添加在所有主机上添加好所需的 fdb 记录。</p>\n<h4>第三版</h4>\n<p>去掉 L2MISS handler。需要添加 n-1 条路由表记录，这些路由表记录和前面不同的是，除了将路由指向 VXLAN interface，还指定了通过 VXLAN 之后下一跳的地址（对应主机的 ip 地址）。这样就只需要每个主机 1 条 arp 记录，以及每个主机 1 条 fdb 记录。</p>\n<p>这样 flannel daemon 就不需要监听任何内核的事件，只需要在机器加入、退出集群的时候维护好这些记录。即使 flannel daemon 挂了整个 overlay 网络还是能（在很长一段时间内）正常运行。</p>\n<h3>Reference</h3>\n<ol>\n<li><a href=\"https://github.com/yangyuqian/k8s-the-hard-way/blob/master/network/vxlan-flannel-cn.md\">vxlan 在 Flannel 中的 Overlay 网络的实现</a></li>\n<li><a href=\"https://cizixs.com/2017/09/25/vxlan-protocol-introduction/\">vxlan 协议原理简介</a></li>\n<li><a href=\"https://www.sdnlab.com/21143.html\">容器 Flannel vxlan 基本原理和验证</a></li>\n<li><a href=\"https://tools.ietf.org/html/rfc7348\">rfc7348</a></li>\n<li><a href=\"https://github.com/coreos/Flannel/blob/master/backend/vxlan/vxlan.go#L18\">Flannel design notes and history</a></li>\n</ol>","frontmatter":{"title":"VXLAN & Flannel","date":"December 23, 2019","description":"关于VXLAN、Flannel以及搭建一个简单的VXLAN网络。"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/VXLAN&Flannel/","previous":null,"next":null}}}