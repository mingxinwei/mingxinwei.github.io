<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Mingxin]]></title><description><![CDATA[A personal website of Mingxin]]></description><link>https://mingxin.io</link><generator>GatsbyJS</generator><lastBuildDate>Thu, 09 Apr 2020 15:46:36 GMT</lastBuildDate><item><title><![CDATA[VXLAN & Flannel]]></title><description><![CDATA[VXLAN 是什么 Virtual Extensible LAN(VXLAN)是一个在三层网络上模拟二层网络的网络虚拟化技术。可以解决云计算场景下子网不够用的问题。 有一个和 VXLAN 名字和解决的问题都很相似的技术：VLAN，VXLAN 和 VLAN…]]></description><link>https://mingxin.io/VXLAN&amp;Flannel/</link><guid isPermaLink="false">https://mingxin.io/VXLAN&amp;Flannel/</guid><pubDate>Mon, 23 Dec 2019 11:51:30 GMT</pubDate><content:encoded>&lt;h3&gt;VXLAN 是什么&lt;/h3&gt;
&lt;p&gt;Virtual Extensible LAN(VXLAN)是一个在三层网络上模拟二层网络的网络虚拟化技术。可以解决云计算场景下子网不够用的问题。&lt;/p&gt;
&lt;p&gt;有一个和 VXLAN 名字和解决的问题都很相似的技术：VLAN，VXLAN 和 VLAN 相比的优点是什么？&lt;/p&gt;
&lt;p&gt;传统 VLAN 只能支持 4000 个子网，VXLAN 可以支持 1600 万个子网。&lt;/p&gt;
&lt;h3&gt;VXLAN 原理&lt;/h3&gt;
&lt;p&gt;使用三层网络的 udp 包来封装二层的数据包。..&lt;/p&gt;
&lt;h4&gt;包结构&lt;/h4&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/8eebca9b5c20497d223e8f0e3c856c81/3cdf1/vnet-vxlan-20191107165758344.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 47.410008779631255%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAACf0lEQVQoz02RXUjTARTF11sPFRG99hYUPRRGWA8VPvYiRJbWjIr8SkijILEQ8yOtLPPBItDCraVrzpXOrTl1S3OburkP59x0m7ql07CVaTl1hb/+Sg9dOJzDvdzDuVzR4KANq20Iu8PFx85OBu7fYKQyH3PFLZofldL8uJyWqlKUG/phidArQfGPN+aKiiK0tVWY+gdxu0cQOZwu7HYn9mEPZr2OSMo+SN+PLeUgOxu8bFMvsqPWzJmsfMSZuZTXPGc0FGHAM86If5I2h58XxXewC6E8oz5E/YLzJqx2utta8aYe4seVI1jSEkmqlHG0pp2ke3VkZ+aQl51DZUkpGpUKlVyORqnkleQNL+/exCJ4uFxuRKFQGK/Xx7g/QMDvZ8SgY6hdibtLw1jHe6zK1/gEtuk1dDbL0b9tRNsoRa9opEMuo6tJiuWDWtgPMjMzgwih4mtrRCIRlpaWiK/D4kqcxd/rRGNxwtEFvq/9YWk1zmpsmYXoPCu/fvJ/La+uEovFNrUoGAwSCATw+Xy4h4fxeEYJOIcImw1MmLoZM+oI9uqZ9Q4zODmLxhVAPeSj1T6GNziJxWTCJMBgMAr7wslWq43ubiNdAnqMPRgtVryyZ8ykJxBOP8z05WOETu8lWl/GKeNXtkgm2N40xa6WOeq7+snNuEpmTi5i8UWeVD9FZDJZ0Gh1qNUatO1a1J1GPNJa5i4l8lkwm844SfjsAb41PCC5J8pW2RS75SH2vPuCxGjlenY2GVnXSE27QPWGocPhpKf3E319QnQBZpuD8XYFwdvn8Becx18oxpeXzLyqjnzLHAmKUU6oxjjeNoHK7KCsqIhi4fMFBYVIJFL+AppxJ65sXr/CAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;img&quot;
        title=&quot;img&quot;
        src=&quot;/static/8eebca9b5c20497d223e8f0e3c856c81/799d3/vnet-vxlan-20191107165758344.png&quot;
        srcset=&quot;/static/8eebca9b5c20497d223e8f0e3c856c81/00d96/vnet-vxlan-20191107165758344.png 148w,
/static/8eebca9b5c20497d223e8f0e3c856c81/0b23c/vnet-vxlan-20191107165758344.png 295w,
/static/8eebca9b5c20497d223e8f0e3c856c81/799d3/vnet-vxlan-20191107165758344.png 590w,
/static/8eebca9b5c20497d223e8f0e3c856c81/2a3d6/vnet-vxlan-20191107165758344.png 885w,
/static/8eebca9b5c20497d223e8f0e3c856c81/3cdf1/vnet-vxlan-20191107165758344.png 1139w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（图片来源：&lt;a href=&quot;https://cizixs.com/2017/09/25/vxlan-protocol-introduction/&quot;&gt;vxlan 协议原理简介&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;从最内层往外看：最内层的 Original L2 Frame 是虚拟子网的二层数据包，在前面加上 VXLAN 的 header。之后就被当作一个普通的 udp 包的 payload，在真正的物理子网上发送出去。&lt;/p&gt;
&lt;p&gt;这里可以注意一下 VXLAN Header 中的 VNID 字段，共占 24bit，所以 VXLAN 能够支持的不同子网共有&lt;code class=&quot;language-text&quot;&gt;2^24 = 16777216&lt;/code&gt;个。&lt;/p&gt;
&lt;h4&gt;组网原理&lt;/h4&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 584px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b9243aa32a333bf609d27ccd5bc2c876/8abfd/5652c940898f4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.88356164383562%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACGElEQVQoz21STW/TQBDNb+HOhR/AHW6ICwcqcQBxCeIEiAPihFRBQfQEIqh89lAqEFFbGkFQQk0a0kKb4MaxG0IcJ3FTN7ZjpwqJ7c1jvXaUIDrS7M7uzLydfTMRTMhwOGTqi0uCPSXZOHFHxMmZXZg98l/cpO1LxF/IEQFeGJPgDRy7mcfx2wX8Vg0MiQtCxrGjnYR2ZBI9AKYB1O4PHPQsHctZCecf8bgQK0KsKOhaJrrdQwwc9x/Qkc0qrGh9tCxndA14f2C0Naiaic5hD7VmG5pho+cO6bmPbseArbdoBUFO0xygpg/GX57P6eDKNgN7v9nCy7U68lId7VIGe/wapI00dtY/o5pLQMisIpkT8CRRwmK2yXJW+Q6WCuYIkOBWvIk333XKjYcb7xo4N9fA4hcRldfXsTF7EamHUXy8H0V2ZgrfYtcwz8mYeq7gykLdJwoxTsODT/sMPLK1I6Mg1tBoGcGP+xZIZ485/Z4OKAM+W7726OKFtHimCjg2OynqAfKCDKGs0qYQgkShioK8D8dx8DRdxL2VbUiqERJNAl59DRuwLWu4u7KFF1yJFughS4FSQp35GYfTwk/EFRl9Cnh5M4OzX5PgtBZL9uiDo1FySTCHS00FZ7gkrv7I0gAPr6plPP4ljpuSrk+jqMXhui7e7l7CM/40atZ6OErexFgFtqR/wBx/CvFyFP6V2F4Gf7DAfH8BH+HcG9rQqYEAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;img&quot;
        title=&quot;img&quot;
        src=&quot;/static/b9243aa32a333bf609d27ccd5bc2c876/8abfd/5652c940898f4.png&quot;
        srcset=&quot;/static/b9243aa32a333bf609d27ccd5bc2c876/00d96/5652c940898f4.png 148w,
/static/b9243aa32a333bf609d27ccd5bc2c876/0b23c/5652c940898f4.png 295w,
/static/b9243aa32a333bf609d27ccd5bc2c876/8abfd/5652c940898f4.png 584w&quot;
        sizes=&quot;(max-width: 584px) 100vw, 584px&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（图片来源：&lt;a href=&quot;https://cizixs.com/2017/09/25/vxlan-protocol-introduction/&quot;&gt;vxlan 协议原理简介&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;一个 VXLAN 网络中有几个重要的部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VTEP，VXLAN Tunnel Endpoint。这个是每个机器上都会有一个 VXLAN 网络的 endpoint，负责对数据包进行封包和解包。可以是软件实现，也可以是专有的硬件。&lt;/li&gt;
&lt;li&gt;VNI，区分不同 VXLAN 网络的标识符，这个主要是设置在每个 VTEP 上，VNI 相同的 VTEP 在一个子网里。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;几台机器想要组成一个 VXLAN，需要哪些信息？换句话说，假设已经有了一个 VXLAN 网络，在这个网络内的机器 A 想要给机器 B 发个数据包，有哪些地址字段需要填写？&lt;/p&gt;
&lt;p&gt;需要填写的字段有 4 个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内层（虚拟子网）的 IP 地址&lt;/li&gt;
&lt;li&gt;内层的 MAC 地址&lt;/li&gt;
&lt;li&gt;外层（物理子网）的 IP 地址&lt;/li&gt;
&lt;li&gt;外层的 MAC 地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A 上的应用要给 B 发消息，肯定是知道 B 的 IP 地址（内层 IP 地址）；并且如果知道外层的 IP 地址，通过物理子网的 arp 可以知道外层的 MAC。所以还缺少的地址有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内层（虚拟子网）的 MAC 地址&lt;/li&gt;
&lt;li&gt;外层（物理子网）的 IP 地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;想要得到这两个信息，一般有组播和控制中心两种办法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组播是通过在组播地址上组播，VTEP 自动学习着两个信息。这里先不展开介绍&lt;/li&gt;
&lt;li&gt;控制中心是通过一个中心数据库来提供这两个信息，比如在 k8s 中可以在创建 pod 的时候，把 1. pod 的 MAC 地址 2. pod 所在机器的 IP 地址存储到 etcd 里，在后面别的机器（上的 pod）需要和这个 pod 通信的时候，可以通过像 etcd 发起查询得到这两个信息，就可以通信了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;在 linux 中实践 VXLAN&lt;/h3&gt;
&lt;h4&gt;目标&lt;/h4&gt;
&lt;p&gt;在 2 台机器上构建一个 VXLAN，使机器&amp;#x3C;==&gt;机器，机器&amp;#x3C;==&gt;容器，容器&amp;#x3C;==&gt;容器之间都可以通信。&lt;/p&gt;
&lt;h4&gt;网络拓扑&lt;/h4&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/12be2088c186b3768405cb0713bbedc6/77a09/expected-network-topography-vxlan.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 76.95852534562212%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAADb0lEQVQ4y62Ty2/cVBSHPeNpoIAQEumi4j9ALBCiWxY0BaEgVQ2QVKrSBRQEAkUsALHKkgXsYAEFReIhCmyAlEZQtWEmzXTs8bXv9WvG9jz8nlcaEiUlzDBOfbjXURA7WHClo3tk/86n87iHW3jvAjf36mnuzQ9e4g7PqekzE+z+pRo8Jje24IdrMoj1DVDatz9i308+/ezRY8cnc8xnseL2z9y30kXuK/FDjgOAPLNgO+btbpOfeubUvecvvHj0ldem+Mvl+gOivTW9ivzpSm3jtGBtP8wg31z+fuLJp07e987iuxMs1um2+Ginyxs9nef+93PD/vWLor76ndbDH99sri+Rjvyp3iOfaD3yuRyLU0xTqTcLotM6wvxqUH7jGr66IrnCkuSLn1W9ypLRVy9S+xLH0utca9eBcOSDv+NCs+eAt+tCbWBANApAaJWvMghuqTmtQwqZH6HiFmyCd7sN7VstcDfbYG/WqVlws7kGnBrjsdk3EiPUx8QhiR7pY9SWRlqsgeSKKwxCGgYDZv0hsfxje6cJtZ45VFvqWHe1seLJY6lZTcqNtRGndXDKMtI8NUUmAiPSU6ld3dcpEIcoA8oOydX65iHwir/nMmCi2DKQBk4VD6UUCJXmekozVFIqBtUnabUughHrIHtovz6ogxIcANU2yxAfApczYN9M5IYMSlMBNSQp9jGtSNg/AA4o0CWpQATQfBVYhmbPANmXlhkEWThHQf8AelmGVbMKUk0C2ZVS2UU0wxt7DHgnK89XUhxSo7fR0feDPR/0LrnCIN29wd89pENZ9n93gfgkwQHVU9NCNbU3bKBTvsORQAGRCGNkoMQa1BPak0RQhJHds0HtKBnQ/y3KIbeaAZVQ+snp2CDIlaEe6InVrycCFhIWjyN5yCkR+oP1kAQY3F36BG5ZQKcMnT9j0HtqiUFqnpVXXFQ4KBldCod+pnE2bYiGIWgRAVoVqF0ZuIpXepQ+znMl8/osjtEM6aCZkrn6AvKFcyisPHG4AHTFslsIisfXneJs2VmbpYDnqe65onl9jvZ2Zr21eua/LBN/bHIyf+LxE4XJhx7M/6taDsW8Huv8CIb5xfcXj8ydn7174a2Fe+ividJa8ZEwDHWMsWxZVisIgrdZzNn5s/cz3fzL83ddWvm6wGLVUOVRKPB/AWY1u8P1sZwsAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;img&quot;
        title=&quot;img&quot;
        src=&quot;/static/12be2088c186b3768405cb0713bbedc6/799d3/expected-network-topography-vxlan.png&quot;
        srcset=&quot;/static/12be2088c186b3768405cb0713bbedc6/00d96/expected-network-topography-vxlan.png 148w,
/static/12be2088c186b3768405cb0713bbedc6/0b23c/expected-network-topography-vxlan.png 295w,
/static/12be2088c186b3768405cb0713bbedc6/799d3/expected-network-topography-vxlan.png 590w,
/static/12be2088c186b3768405cb0713bbedc6/77a09/expected-network-topography-vxlan.png 651w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（图片来源: &lt;a href=&quot;https://github.com/yangyuqian/k8s-the-hard-way/blob/master/network/vxlan-flannel-cn.md&quot;&gt;VXLAN 在 Flannel 中的 Overlay 网络的实现&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;需要搭建的 overlay 子网为 192.1.0.0/16。&lt;/p&gt;
&lt;h4&gt;步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;创建 VXLAN interface（VTEP），给 VXLAN 分配 ip&lt;/li&gt;
&lt;li&gt;路由表新增一项，把虚拟子网的流量交给 VTEP 处理&lt;/li&gt;
&lt;li&gt;上面提到要打包缺少的地址：「内层（虚拟子网）的 MAC 地址」，这里通过手动修改 ARP 表实现。ARP 表新增几项，把 overlay 网络上需要访问的容器（机器）ip 地址都指向&lt;strong&gt;该机器的 VTEP 的 MAC 地址&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;另一个缺少的地址：「外层（物理子网）的 IP 地址」，通过修改转发表来实现。转发表新增一项，把发往 VTEP MAC 地址的流量都指向另一台机器的物理子网 ip&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;一个数据包的奥德赛&lt;/h4&gt;
&lt;p&gt;经过这样的配置之后，一个数据包怎么从一个机器/容器路由到另一个机器/容器呢？这里选择讲解一个最长的路由路径：容器&amp;#x3C;==&gt;容器，其他情况都包含在这个路径里。
假设 node1 上的容器 A 192.1.78.2 想要发一个数据包给 node2 上的容器 B 192.1.87.2&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据包从 A 发出，通过 docker bridge 来到 docker0 interface，docker0 需要知道该把这个数据包发给谁，于是他查询了路由表，发现命中了这条规则&lt;code class=&quot;language-text&quot;&gt;192.1.0.0/16&lt;/code&gt;，于是发往 vxlan.1 interface。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vxlan.1 收到数据包之后开始打包，需要填写 4 个地址：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;内层（虚拟子网）的 IP 地址&lt;/li&gt;
&lt;li&gt;内层的 MAC 地址&lt;/li&gt;
&lt;li&gt;外层（物理子网）的 IP 地址&lt;/li&gt;
&lt;li&gt;外层的 MAC 地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1 已知；2 会通过 arp 请求去查找，命中前面手动维护的本地 arp 缓存，得到 node2 VTEP 的 MAC 地址；3 会命中手动维护的 fdb 转发表，得到 node2 的物理子网 IP 地址；4 通过物理子网 arp 得到。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;打包完成后，得到一个物理子网的普通 udp 包发往 node2 的 4789 端口。node2 的 vxlan.1 interface 监听该端口，接到 udp 包之后解开封装得到内层的数据包。&lt;/li&gt;
&lt;li&gt;vxlan.1 需要知道数据包该发往哪里，同样查询本机的路由表，命中&lt;code class=&quot;language-text&quot;&gt;192.1.87.0/24&lt;/code&gt;，发往 docker0 interface。docker0 再将数据包发给容器 B。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;实践&lt;/h4&gt;
&lt;h5&gt;1. 实现机器&amp;#x3C;==&gt;机器通信&lt;/h5&gt;
&lt;p&gt;将以上步骤写到一起，方便执行：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# step1&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;IP&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# 本机ip&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;DEST_IP&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# 另一台机器ip&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;VTEP_IP&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# 本机VTEP ip&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;PREFIX&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;vxlan
&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;PORT&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4789&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;VNI&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;SUBNET&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;192&lt;/span&gt;.&lt;span class=&quot;token variable&quot;&gt;$VNI&lt;/span&gt;.0.0/16
&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;DEVICE_NAME&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$PREFIX&lt;/span&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$VNI&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$DEVICE_NAME&lt;/span&gt; &lt;span class=&quot;token builtin class-name&quot;&gt;type&lt;/span&gt; vxlan &lt;span class=&quot;token function&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$VNI&lt;/span&gt; dev eth0 dstport &lt;span class=&quot;token variable&quot;&gt;$PORT&lt;/span&gt; nolearning
&lt;span class=&quot;token function&quot;&gt;ip&lt;/span&gt; address &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$VTEP_IP&lt;/span&gt; dev &lt;span class=&quot;token variable&quot;&gt;$DEVICE_NAME&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;token builtin class-name&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$DEVICE_NAME&lt;/span&gt; up
&lt;span class=&quot;token function&quot;&gt;ip&lt;/span&gt; route &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$SUBNET&lt;/span&gt; dev &lt;span class=&quot;token variable&quot;&gt;$DEVICE_NAME&lt;/span&gt; scope global

&lt;span class=&quot;token comment&quot;&gt;# step2 需要拿到step1的结果后在再进行&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;ANOTHER_VTEP_MAC&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# 需要等另一台机器的VXLAN设备创建之后，查看其MAC地址&lt;/span&gt;
bridge fdb &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$ANOTHER_VTEP_MAC&lt;/span&gt; dev &lt;span class=&quot;token variable&quot;&gt;$DEVICE_NAME&lt;/span&gt; dst &lt;span class=&quot;token variable&quot;&gt;$DEST_IP&lt;/span&gt;

&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;ANOTHER_NODE_IP&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# 需要访问的另一台机器上的（容器或机器）ip&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;ip&lt;/span&gt; neighbor &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$ANOTHER_NODE_IP&lt;/span&gt; lladdr &lt;span class=&quot;token variable&quot;&gt;$ANOTHER_VTEP_MAC&lt;/span&gt; dev &lt;span class=&quot;token variable&quot;&gt;$DEVICE_NAME&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Node1:&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b75473b2711743edf07bca9b402ad511/0fd75/image-20191223172234150.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 89.75188781014025%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAAsSAAALEgHS3X78AAACc0lEQVQ4y11TiW6jMBDlW5q2aQg3NrdtMNhcCSTpdrW7//8h+4A2jSo9oRFieMfMGP7f0XvvnUknchTNJSraMFMk11GhHVraRLxY8SP2Vvz6VRvur945t/ZJRVXP6lmoSyHPfiyBIKmBVzt5bKYWdaxotzX7/xZme9JpPcr21gwfMeu8uLICtjPp04E8H6NHvADfzNB81vagQqYJBGcqYl3Ke5rrY8AOXvbmZm9OiufBXWs3u2sB82nxfOlo2Yl6ZvWkxt9q+ID4rBwT0UOFG5UOEfBvhxxB7J30i/nWu1PrDNovFHziO5B7sVx6aOlGFWrTL57Xr8H5/Cjbl6oYZn6+Vt1NqBlpk1zRos2qcTEfVfgjODdy/O4xP+PgZBkfcjGik9dTwns0BGkNbcCPtHaASe+ZGfAAe1zNVXvjzZyJAVbBHKyECycVzoIStPAMO0huE29YIefNxOQZE+bqgoLVZyanVAwb/2b1Drz5ThvzAFVenUCOqEGOGlpMPz94+X4d0h5z8vIfc1qa4RANaJPdTXbvC38zQwuYgTBtoBwE26oC6IftT9nIEMOE1LXnkxZPWuggbdADX7CKzOHcJhzA8PA79BuWz7AbvJ6xmxs5VKSi30he4BNS4RP1CtRYuP0q3jjELFFjUg+5PMW8By3Gm/AOntcbio4msUzimcQxiWuGe5NA9qbc8HEVQ7PtdpS3OVaS9zCSbUWQl5QXRDDCBBUyFmkiLSKQBdbG8E7tUcmjrLy0xiv4xElgQ1HgHsOs8XPlpY2fKRO3vWa+7Q9geH9G7/Z5GMgJhkt9rfQVBfhLfSmX/KeiOkFUpS8wdV/v/yei7yQvyITXAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;image-20191223172234150&quot;
        title=&quot;image-20191223172234150&quot;
        src=&quot;/static/b75473b2711743edf07bca9b402ad511/799d3/image-20191223172234150.png&quot;
        srcset=&quot;/static/b75473b2711743edf07bca9b402ad511/00d96/image-20191223172234150.png 148w,
/static/b75473b2711743edf07bca9b402ad511/0b23c/image-20191223172234150.png 295w,
/static/b75473b2711743edf07bca9b402ad511/799d3/image-20191223172234150.png 590w,
/static/b75473b2711743edf07bca9b402ad511/2a3d6/image-20191223172234150.png 885w,
/static/b75473b2711743edf07bca9b402ad511/ae92f/image-20191223172234150.png 1180w,
/static/b75473b2711743edf07bca9b402ad511/0fd75/image-20191223172234150.png 1854w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Node2 :&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/594f065dc1585d6f878c52683ea095b8/df3b2/image-20191223172531204.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 87.02906350914962%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsSAAALEgHS3X78AAACX0lEQVQ4y1VTCXKjMBDkKZs4F5c4BQIJJC5z+kw2qf3/R7YFjjdb1TWlstXTM93C8L5m/8/inoe0XWR3psVARR/xPSpJKpeqJyf9id2K7WyQ80jOgzPvYzWK5iTak2iOXlKRRAWs8Vnz7LKfTOJQx6Eb39DKX/OmXA3vzfTJyslPayeWDxb99Rbt7OQGi6LaNjU3sp0YoJHrCOWg7MOsC/meyYmpORa9E5VmIN68/NXnr16Os+nzFy/fbbOATD4nwL0MkRp4dcirQz1+AOCjCzbH2uhiR6UVFqhuLF9I9k2+jN77RJY+rgYMnJaj7K+ZmoG8WsCHBWHe4fYzyUDD5DcLNLlo8uFYLteyv8j9JZVzKkeA1wcwYRhsg/gd//wD+dXNWDFiYG11c4SyGysYtt14MGPg0aJ3/KeMq5iw7C4ActIDVwsVQ5i1a87yron8nBi1hoW6BchWUECw6M4go4JftDrtpBwxM0zW266jrpWhPt/dRgBMzhz89sTXLnl9wMJ2WCAYiLx954QD6s3qm2FJBZ2yO6v+CsNwQF3nX1I5wectJLwZew0M5NvmIOPXBIZpTa2MeFARcpi3QdYi1Q3wnFAFgO+ltRUKPDjD8oSoj3dBHEDGwlDTE7psp5E9IWGXPWJb92aBJptC0nFmwyI6RHVqpt/oghWivNNu+zn10tRjjCTcZzzI3IDjtaA1LDBI35lNZSrlsirmPd4jtoAyLXp8nkmi0qyh+Cut4kSFkfCostbJsa9B8DY/JvfQh7KnvMf3sL3qmO8hnqo5UTMtx1gMftb6mfYPbm2e/QU0reFPJmRM5QAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;image-20191223172531204&quot;
        title=&quot;image-20191223172531204&quot;
        src=&quot;/static/594f065dc1585d6f878c52683ea095b8/799d3/image-20191223172531204.png&quot;
        srcset=&quot;/static/594f065dc1585d6f878c52683ea095b8/00d96/image-20191223172531204.png 148w,
/static/594f065dc1585d6f878c52683ea095b8/0b23c/image-20191223172531204.png 295w,
/static/594f065dc1585d6f878c52683ea095b8/799d3/image-20191223172531204.png 590w,
/static/594f065dc1585d6f878c52683ea095b8/2a3d6/image-20191223172531204.png 885w,
/static/594f065dc1585d6f878c52683ea095b8/ae92f/image-20191223172531204.png 1180w,
/static/594f065dc1585d6f878c52683ea095b8/df3b2/image-20191223172531204.png 1858w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;查看一下这样执行之后机器上的路由表、arp 表、和 fdb 转发表的内容，这里以 node1 为例：&lt;/p&gt;
&lt;p&gt;路由表：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;root@VM-0-7-ubuntu:~&lt;span class=&quot;token comment&quot;&gt;# ip route&lt;/span&gt;
default via &lt;span class=&quot;token number&quot;&gt;172.17&lt;/span&gt;.0.1 dev eth0 proto static
&lt;span class=&quot;token number&quot;&gt;172.17&lt;/span&gt;.0.0/20 dev eth0 proto kernel scope &lt;span class=&quot;token function&quot;&gt;link&lt;/span&gt; src &lt;span class=&quot;token number&quot;&gt;172.17&lt;/span&gt;.0.7
&lt;span class=&quot;token number&quot;&gt;172.18&lt;/span&gt;.0.0/16 dev docker0 proto kernel scope &lt;span class=&quot;token function&quot;&gt;link&lt;/span&gt; src &lt;span class=&quot;token number&quot;&gt;172.18&lt;/span&gt;.0.1 linkdown
&lt;span class=&quot;token number&quot;&gt;192.1&lt;/span&gt;.0.0/16 dev vxlan.1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;192.1.0.0/16 dev vxlan.1&lt;/code&gt;这条规则指定了&lt;code class=&quot;language-text&quot;&gt;192.1.0.0/16&lt;/code&gt;这个子网的流量都会通过&lt;code class=&quot;language-text&quot;&gt;vxlan.1&lt;/code&gt;这个设备来处理。&lt;/p&gt;
&lt;p&gt;arp 表：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;root@VM-0-7-ubuntu:~&lt;span class=&quot;token comment&quot;&gt;# ip neighbor&lt;/span&gt;
&lt;span class=&quot;token number&quot;&gt;192.1&lt;/span&gt;.87.0 dev vxlan.1 lladdr d2:04:98:13:a7:aa PERMANENT
&lt;span class=&quot;token number&quot;&gt;172.17&lt;/span&gt;.0.1 dev eth0 lladdr fe:ee:00:2e:16:9a REACHABLE
&lt;span class=&quot;token number&quot;&gt;172.17&lt;/span&gt;.0.4 dev eth0 lladdr fe:ee:00:2e:16:9a STALE&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 arp 表中添加了我们需要访问的 ip &lt;code class=&quot;language-text&quot;&gt;192.1.87.0&lt;/code&gt;的 MAC 地址（因为我们需要 ping 的 node2 的机器 ip）。需要注意的是，如果等下需要访问 node2 容器的 ip 地址（比如&lt;code class=&quot;language-text&quot;&gt;192.1.87.2&lt;/code&gt;)，这里还需要添加一条记录。&lt;/p&gt;
&lt;p&gt;fdb 转发表：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;root@VM-0-7-ubuntu:~&lt;span class=&quot;token comment&quot;&gt;# bridge fdb&lt;/span&gt;
&lt;span class=&quot;token number&quot;&gt;33&lt;/span&gt;:33:00:00:00:01 dev eth0 self permanent
01:00:5e:00:00:01 dev eth0 self permanent
&lt;span class=&quot;token number&quot;&gt;33&lt;/span&gt;:33:ff:7b:75:85 dev eth0 self permanent
01:80:c2:00:00:00 dev eth0 self permanent
01:80:c2:00:00:03 dev eth0 self permanent
01:80:c2:00:00:0e dev eth0 self permanent
&lt;span class=&quot;token number&quot;&gt;33&lt;/span&gt;:33:00:00:00:01 dev docker0 self permanent
01:00:5e:00:00:01 dev docker0 self permanent
02:42:c0:52:69:49 dev docker0 vlan &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; master docker0 permanent
02:42:c0:52:69:49 dev docker0 master docker0 permanent
d2:04:98:13:a7:aa dev vxlan.1 dst &lt;span class=&quot;token number&quot;&gt;172.17&lt;/span&gt;.0.4 self permanent&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定了发往&lt;code class=&quot;language-text&quot;&gt;d2:04:98:13:a7:aa&lt;/code&gt;这个 MAC 地址（node2 VTEP 的 MAC 地址）的流量都发向&lt;code class=&quot;language-text&quot;&gt;172.17.0.4&lt;/code&gt;这个 ip。&lt;/p&gt;
&lt;p&gt;这样就可以 ping 通两台机器了：&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d97c5144bd758c68eee7f44af30edb81/03e06/image-20191223172718418.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 18.152524167561758%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAmklEQVQY043P2w6CMAwGYJ5GQFE5bGxjB0AYA3z/5/ndluCVMVw0bZr0a5sw60BHCzYsUGqF6XcovYHxCXXT41lq5FeGLG9PRSK4RScWCGHBfXTSQSrnwTnWYUHoX1KCNKNx6Mg/Qdk5aH+RUltEtNnQsgm0fYHQEWWlUdUGDRn+Ql+QLyvY7FH7hjF7HAzYAd4fMr58K8Qp8AP2Q4EFiqhsKQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;image-20191223172718418&quot;
        title=&quot;image-20191223172718418&quot;
        src=&quot;/static/d97c5144bd758c68eee7f44af30edb81/799d3/image-20191223172718418.png&quot;
        srcset=&quot;/static/d97c5144bd758c68eee7f44af30edb81/00d96/image-20191223172718418.png 148w,
/static/d97c5144bd758c68eee7f44af30edb81/0b23c/image-20191223172718418.png 295w,
/static/d97c5144bd758c68eee7f44af30edb81/799d3/image-20191223172718418.png 590w,
/static/d97c5144bd758c68eee7f44af30edb81/2a3d6/image-20191223172718418.png 885w,
/static/d97c5144bd758c68eee7f44af30edb81/ae92f/image-20191223172718418.png 1180w,
/static/d97c5144bd758c68eee7f44af30edb81/03e06/image-20191223172718418.png 1862w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;2. 实现容器&amp;#x3C;==&gt;容器通信&lt;/h5&gt;
&lt;p&gt;有了前面机器&amp;#x3C;==&gt;机器的通信基础之后，容器&amp;#x3C;==&gt;容器就比较简单了。&lt;/p&gt;
&lt;p&gt;首先需要改一下 docker 的子网，修改 docker 的启动参数并重启 docker：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; /etc/docker/daemon.json &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;EOF
{&quot;bip&quot;:&quot;192.1.78.1/24&quot;}
EOF&lt;/span&gt;

systemctl restart docker&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后启动 docker 容器：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;docker run -it --rm busybox&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看一下容器的 ip 地址：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;/ &lt;span class=&quot;token comment&quot;&gt;# ip a&lt;/span&gt;
&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;: lo: &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;LOOPBACK,UP,LOWER_UP&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; mtu &lt;span class=&quot;token number&quot;&gt;65536&lt;/span&gt; qdisc noqueue qlen &lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet &lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1/8 scope &lt;span class=&quot;token function&quot;&gt;host&lt;/span&gt; lo
       valid_lft forever preferred_lft forever
&lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;: eth0@if7: &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; mtu &lt;span class=&quot;token number&quot;&gt;1500&lt;/span&gt; qdisc noqueue
    link/ether 02:42:c0:01:4e:02 brd ff:ff:ff:ff:ff:ff
    inet &lt;span class=&quot;token number&quot;&gt;192.1&lt;/span&gt;.78.2/24 brd &lt;span class=&quot;token number&quot;&gt;192.1&lt;/span&gt;.78.255 scope global eth0
       valid_lft forever preferred_lft forever&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 node2 上面重复以上步骤（对应的子网地址需要改一下）。&lt;/p&gt;
&lt;p&gt;可以看到 node1 上 container 的 ip 是&lt;code class=&quot;language-text&quot;&gt;192.1.78.2&lt;/code&gt;，node2 上的 container 的 ip 是&lt;code class=&quot;language-text&quot;&gt;192.1.87.2&lt;/code&gt;，所以需要在 2 台机器上分别添加这两个 ip 的 arp 记录：&lt;/p&gt;
&lt;p&gt;Node1:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;ANOTHER_NODE_IP&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;192.1&lt;/span&gt;.87.2 &lt;span class=&quot;token comment&quot;&gt;# 需要访问的另一台机器上的（容器或机器）ip&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;ip&lt;/span&gt; neighbor &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$ANOTHER_NODE_IP&lt;/span&gt; lladdr &lt;span class=&quot;token variable&quot;&gt;$ANOTHER_VTEP_MAC&lt;/span&gt; dev &lt;span class=&quot;token variable&quot;&gt;$DEVICE_NAME&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Node2:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;ANOTHER_NODE_IP&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;192.1&lt;/span&gt;.78.2 &lt;span class=&quot;token comment&quot;&gt;# 需要访问的另一台机器上的（容器或机器）ip&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;ip&lt;/span&gt; neighbor &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$ANOTHER_NODE_IP&lt;/span&gt; lladdr &lt;span class=&quot;token variable&quot;&gt;$ANOTHER_VTEP_MAC&lt;/span&gt; dev &lt;span class=&quot;token variable&quot;&gt;$DEVICE_NAME&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以 ping 通容器…了吗？并没有，这时候 ping 会发现是 ping 不通的。&lt;/p&gt;
&lt;p&gt;经过很长时间的摸索，我发现是 docker 设置的 iptables 的规则阻止了 ping 包:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;root@VM-0-4-ubuntu:~&lt;span class=&quot;token comment&quot;&gt;# iptables -L -v&lt;/span&gt;
Chain INPUT &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;policy ACCEPT &lt;span class=&quot;token number&quot;&gt;1322&lt;/span&gt; packets, 897K bytes&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 pkts bytes target     prot opt &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;     out     &lt;span class=&quot;token builtin class-name&quot;&gt;source&lt;/span&gt;               destination

Chain FORWARD &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;policy DROP &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt; packets, &lt;span class=&quot;token number&quot;&gt;840&lt;/span&gt; bytes&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 pkts bytes target     prot opt &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;     out     &lt;span class=&quot;token builtin class-name&quot;&gt;source&lt;/span&gt;               destination
   &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;token number&quot;&gt;840&lt;/span&gt; DOCKER-&lt;span class=&quot;token environment constant&quot;&gt;USER&lt;/span&gt;  all  --  any    any     anywhere             anywhere
   &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;token number&quot;&gt;840&lt;/span&gt; DOCKER-ISOLATION-STAGE-1  all  --  any    any     anywhere             anywhere
    &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; ACCEPT     all  --  any    docker0  anywhere             anywhere             ctstate RELATED,ESTABLISHED
   &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;token number&quot;&gt;840&lt;/span&gt; DOCKER     all  --  any    docker0  anywhere             anywhere
    &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; ACCEPT     all  --  docker0 &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;docker0  anywhere             anywhere
    &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; ACCEPT     all  --  docker0 docker0  anywhere             anywhere

Chain OUTPUT &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;policy ACCEPT &lt;span class=&quot;token number&quot;&gt;1294&lt;/span&gt; packets, 147K bytes&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 pkts bytes target     prot opt &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;     out     &lt;span class=&quot;token builtin class-name&quot;&gt;source&lt;/span&gt;               destination

Chain DOCKER &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; references&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 pkts bytes target     prot opt &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;     out     &lt;span class=&quot;token builtin class-name&quot;&gt;source&lt;/span&gt;               destination

Chain DOCKER-ISOLATION-STAGE-1 &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; references&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 pkts bytes target     prot opt &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;     out     &lt;span class=&quot;token builtin class-name&quot;&gt;source&lt;/span&gt;               destination
    &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; DOCKER-ISOLATION-STAGE-2  all  --  docker0 &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;docker0  anywhere             anywhere
   &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;token number&quot;&gt;840&lt;/span&gt; RETURN     all  --  any    any     anywhere             anywhere

Chain DOCKER-ISOLATION-STAGE-2 &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; references&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 pkts bytes target     prot opt &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;     out     &lt;span class=&quot;token builtin class-name&quot;&gt;source&lt;/span&gt;               destination
    &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; DROP       all  --  any    docker0  anywhere             anywhere
    &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; RETURN     all  --  any    any     anywhere             anywhere

Chain DOCKER-&lt;span class=&quot;token environment constant&quot;&gt;USER&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; references&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 pkts bytes target     prot opt &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;     out     &lt;span class=&quot;token builtin class-name&quot;&gt;source&lt;/span&gt;               destination
   &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;token number&quot;&gt;840&lt;/span&gt; RETURN     all  --  any    any     anywhere             anywhere&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;iptables 的&lt;code class=&quot;language-text&quot;&gt;FORWARD&lt;/code&gt;chain 阻止了包从&lt;code class=&quot;language-text&quot;&gt;vxlan.1&lt;/code&gt; 到&lt;code class=&quot;language-text&quot;&gt;docker0&lt;/code&gt;interface 的 forward，所以导致 ping 不通。这里不细究&lt;code class=&quot;language-text&quot;&gt;FORWARD&lt;/code&gt;chain 下的 iptables 规则，先简单直接地把&lt;code class=&quot;language-text&quot;&gt;FORWARD&lt;/code&gt;chain 的默认 policy 设置为&lt;code class=&quot;language-text&quot;&gt;ACCEPT&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;iptables -P FORWARD ACCEPT&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样 2 个容器之间就可以 ping 通了：&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/ae933/image-20191223192249290.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 21.720430107526884%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAhUlEQVQY042PSw6DMAxEc5vSUhWqAnF+hIqEoLDh/peZBkvdZ/H0ZC/GHmHSAb1n0JogdQBRwGdYmEmu6HqLWzOiuU9ViBhOzC4zxiSQjnBzmX2GX8qxsnu0VB0qlNn4E1k++3sYv+jfjn3RPhUH1iC8P2BsgnU7W+mNTSpy+FX51dnqyj/PH4DFquWXfAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;image-20191223192249290&quot;
        title=&quot;image-20191223192249290&quot;
        src=&quot;/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/799d3/image-20191223192249290.png&quot;
        srcset=&quot;/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/00d96/image-20191223192249290.png 148w,
/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/0b23c/image-20191223192249290.png 295w,
/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/799d3/image-20191223192249290.png 590w,
/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/2a3d6/image-20191223192249290.png 885w,
/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/ae92f/image-20191223192249290.png 1180w,
/static/43cf0a876f7d5381e7b9f1d2dc7b1fb5/ae933/image-20191223192249290.png 1860w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Flannel and VXLAN&lt;/h3&gt;
&lt;p&gt;Flannel 和 VXLAN 有什么关系？&lt;/p&gt;
&lt;p&gt;Flannel 采用搭建 overlay 网络的方法来满足&lt;a href=&quot;https://kubernetes.io/docs/concepts/cluster-administration/networking/#the-kubernetes-network-model&quot;&gt;k8s 的网络模型&lt;/a&gt;，它提供了几个不通的 backend 来搭建 overlay 网络，其中 VXLAN 是最推荐的一个 backend。VXLAN 在 linux 内核中有良好支持，性能好。&lt;/p&gt;
&lt;p&gt;Flannel 利用 VXLAN 来构建 overlay 网络，本身只维护几个表，其余工作都是 VXLAN 完成。基本原理和上面的手工操作是一样的，只是 flannel 把这个过程自动化了。&lt;/p&gt;
&lt;p&gt;Flannel 一共迭代了 3 个版本：&lt;/p&gt;
&lt;h4&gt;第一版&lt;/h4&gt;
&lt;p&gt;每个机器上的 flannel daemon 会创建 VXLAN interface，并把自己注册为 L2MISS 和 L3MISS 事件的 handler。&lt;/p&gt;
&lt;p&gt;L2MISS 是在 2 层网络的 miss，也就是从 IP 查找 MAC 这一步的 miss（对应上面的地址 2）。Flannel daemon 收到 miss 后会查找存储的数据来给出对应的 MAC 地址，并将其加入 arp 缓存。&lt;/p&gt;
&lt;p&gt;L3MISS 是 host 不知道某个 MAC 地址应该发往哪里时产生的 miss（对应上面的地址 3）。收到 miss 后给出 ip 地址，并加入 fdb。&lt;/p&gt;
&lt;p&gt;这个版本每个机器上需要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 条路由表记录（指向 VXLAN interface）&lt;/li&gt;
&lt;li&gt;每个最近通信过的 container1 条 arp 表记录&lt;/li&gt;
&lt;li&gt;每个主机 1 条 fdb 表记录&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;第二版&lt;/h4&gt;
&lt;p&gt;去掉 L3MISS handler。每次新机器加入集群时，直接添加在所有主机上添加好所需的 fdb 记录。&lt;/p&gt;
&lt;h4&gt;第三版&lt;/h4&gt;
&lt;p&gt;去掉 L2MISS handler。需要添加 n-1 条路由表记录，这些路由表记录和前面不同的是，除了将路由指向 VXLAN interface，还指定了通过 VXLAN 之后下一跳的地址（对应主机的 ip 地址）。这样就只需要每个主机 1 条 arp 记录，以及每个主机 1 条 fdb 记录。&lt;/p&gt;
&lt;p&gt;这样 flannel daemon 就不需要监听任何内核的事件，只需要在机器加入、退出集群的时候维护好这些记录。即使 flannel daemon 挂了整个 overlay 网络还是能（在很长一段时间内）正常运行。&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yangyuqian/k8s-the-hard-way/blob/master/network/vxlan-flannel-cn.md&quot;&gt;vxlan 在 Flannel 中的 Overlay 网络的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cizixs.com/2017/09/25/vxlan-protocol-introduction/&quot;&gt;vxlan 协议原理简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.sdnlab.com/21143.html&quot;&gt;容器 Flannel vxlan 基本原理和验证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7348&quot;&gt;rfc7348&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/coreos/Flannel/blob/master/backend/vxlan/vxlan.go#L18&quot;&gt;Flannel design notes and history&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[Kubernetes 101]]></title><description><![CDATA[Kubernetes 101 Notion Kubeadm 安装 k8s Notion]]></description><link>https://mingxin.io/Kubernenes 101/</link><guid isPermaLink="false">https://mingxin.io/Kubernenes 101/</guid><pubDate>Mon, 21 Oct 2019 10:51:30 GMT</pubDate><content:encoded>&lt;h3&gt;Kubernetes 101&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/shuataren/Kubernetes-101-d1cf0021fbc846c9a846a7656f6a4da5&quot;&gt;Notion&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Kubeadm 安装 k8s&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/shuataren/Kubeadm-k8s-1ba0fc8ee5954255b25b7315b0bf0aa3&quot;&gt;Notion&lt;/a&gt;&lt;/p&gt;</content:encoded></item></channel></rss>